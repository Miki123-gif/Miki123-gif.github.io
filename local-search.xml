<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>random forest</title>
    <link href="/2020/03/14/random-forest/"/>
    <url>/2020/03/14/random-forest/</url>
    
    <content type="html"><![CDATA[<h2 id="集成学习"><a class="markdownIt-Anchor" href="#集成学习"></a> 集成学习</h2><p>三个臭皮匠，抵个诸葛亮，集成多个分类器，得到一个更好的分类器。就像多听几个专家的意见。随机森林是我接触到的第一个集成学习算法。(利用多个机器学习方法集合而成的)</p><h2 id="实现方法"><a class="markdownIt-Anchor" href="#实现方法"></a> 实现方法</h2><ol><li>使用<code>bagging</code>方法（从数据中随机选择<code>n</code>个样本），有放回地选，意味着可能选到相同的</li><li>在样本中所有特征中随机选择<code>k</code>个特征，利用决策树算法(计算信息增益)，来决定结点</li><li>重复上面步骤<code>m</code>次，得到<code>m</code>个结果，然后投票将数据进行分类，这<code>m</code>颗树就是随机森林</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>支持向量机</title>
    <link href="/2020/03/13/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/13/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="支持向量机"><a class="markdownIt-Anchor" href="#支持向量机"></a> 支持向量机</h2><ul><li>向量内积(点乘)，对应相乘相加</li><li>或者表示为<code>|x|*|y|*cosθ</code></li><li>范数，平方和开根号</li><li>推荐b站覃秉丰的机器学习</li><li>核函数就是为了简便内积的运算而引入的，因为有些时候非线性的数据集不好处理，要进行低维转化为高维来寻找超平面，由此引入了核函数</li></ul><p>支持向量机<code>（SVM）support vector machine</code>，主要是用来解决二分类问题的，他被认为是最好的分类方法。因为他能解决线性回归不能解决的分类问题</p><p><strong><code>SVM</code>就是试图把棍放在最佳位置，好让在棍的两边有尽可能大的间隙。这个间隙就是球到棍的距离。</strong></p><p><img src="https://img-blog.csdn.net/20170923170200381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>即使放了更多的球，棍仍然是一个好的分界线。</p><p><img src="https://img-blog.csdn.net/20170923170228849?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>现在，假如我们现在有这样类型的数据，我们不能再使用一条直线将他们很好地区分开来了，使用<code>SVM</code>却可以。</p><p><img src="https://img-blog.csdn.net/20170923170253159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>我们需要对二维平面进行升维处理，找到一个最好的平面，将数据分类，我们将这个平面称为<strong>超平面</strong></p><p><img src="https://img-blog.csdn.net/20170923170319898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><h2 id="松弛变量和惩罚函数"><a class="markdownIt-Anchor" href="#松弛变量和惩罚函数"></a> 松弛变量和惩罚函数</h2><p>因为实际的数据不可能没有错误的**(非线性情况)**，总会有分类错误的点(或者苹果跑到梨子那边了)</p><ul><li>松弛变量就是让支持向量(曲线)不断移动</li><li>惩罚函数就是让分错的点越少越好(最好的时候就是刚好与分错的点相切)</li></ul><h2 id="线性svm"><a class="markdownIt-Anchor" href="#线性svm"></a> 线性<code>SVM</code></h2><p>现在先看一下平面二分类的问题</p><p><img src="https://img-blog.csdn.net/20170923170544874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>黑色实线为分界线，术语称为“决策面”，每个决策面对应了一个线性分类器，虽然从分类结果上看，分类器A和分类器B的效果是相同的。但是他们的性能是有差距的。<strong>在”决策面”不变的情况下，我又添加了一个红点。可以看到，分类器B依然能很好的分类结果，而分类器C则出现了分类错误。</strong></li></ul><p><img src="https://img-blog.csdn.net/20170923170619352?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li><strong>而这个真正的最优解对应的两侧虚线所穿过的样本点，就是<code>SVM</code>中的支持样本点，称为”支持向量”。</strong></li></ul><h2 id="必须掌握的知识点"><a class="markdownIt-Anchor" href="#必须掌握的知识点"></a> 必须掌握的知识点</h2><ol><li>支持向量机的优点，即使数据再大，也比较好用，因为只用关心离决策面附近的几个点就行了</li><li>核函数，将低维映射到高维的一种方法，但是高维的运算(内积)运算量是非常大的，核函数运算厉害之处是，即使映射到高维，但是数据处理依旧是在低维中进行</li><li>线性核函数可以直接使用，不需要设置参数，径向基核函数可以将低维映射到无穷维，但是要设置一些参数，使用广泛的原因是因为，就算参数设置的不是很完美，依旧可以得到比较好的结果</li><li><code>SVM</code>算法优点是：计算量不大，只用计算几个决策边界附近的点就行，错误率比较低</li><li>缺点是：对调制的参数比较敏感，而且只适用于二分类问题</li></ol><h2 id="对线性svm的建模"><a class="markdownIt-Anchor" href="#对线性svm的建模"></a> 对线性<code>SVM</code>的建模</h2><h3 id="确定目标函数优化对象"><a class="markdownIt-Anchor" href="#确定目标函数优化对象"></a> 确定目标函数&amp;&amp;优化对象</h3><ul><li><p>目标函数，就是我们的目的是什么，在上面的例子中，我们希望将支持向量到决策面的距离越大，也就是<strong>分类间隔</strong></p></li><li><p>优化对象，就是我们要调整什么参数，才能使得这个目标对象达到最优，这里我们指的是决策面</p></li><li><p>为了解决实际问题，我们都需要进行公式表示，来对实际数据进行建模，并用数学来对问题进行解答，在建模的过程中，我们通常需要对实际问题进行假设</p></li></ul><h3 id="构建决策面方程"><a class="markdownIt-Anchor" href="#构建决策面方程"></a> 构建决策面方程</h3><p>我们都知道二维空间下一条直线的方式如下所示：</p><p><img src="https://img-blog.csdn.net/20170923170727730?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>现在我们做个小小的改变，让原来的<code>x</code>轴变成<code>x1</code>，<code>y</code>轴变成<code>x2</code>。</p><p><img src="https://img-blog.csdn.net/20170923170755765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>移项得：</p><p><img src="https://img-blog.csdn.net/20170923170822756?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>将公式向量化得：</p><p><img src="https://img-blog.csdn.net/20170923170855067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>进一步向量化，用w列向量和x列向量和标量γ进一步向量化：</p><p><img src="https://img-blog.csdn.net/20170923170921357?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>其中，向量w和x分别为：</p><p><img src="https://img-blog.csdn.net/20170923170949079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>二维空间的直线方程已经推导完成，将其推广到n为空间，就变成了超平面方程。(一个超平面，在二维空间的例子就是一个直线)但是它的公式没变，依然是：</p><p><img src="https://img-blog.csdn.net/20170923171351900?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>不同之处在于：</p><p><img src="https://img-blog.csdn.net/20170923171420742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>我们已经顺利推导出了”决策面”方程，它就是我们的超平面方程，之后，我们统称其为超平面方程。</p><p><img src="https://img-blog.csdn.net/20170923171540791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>这个图非常重要，为了求出图中的距离d，我们只需找到离直线最近的点，再算出点到直线的距离即可</li></ul><p><img src="https://img-blog.csdn.net/20170923171610356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>现在，将直线方程扩展到多维，求得我们现在的超平面方程，对公式进行如下变形：</p><p><img src="https://img-blog.csdn.net/20170923171637926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>这个d就是”分类间隔”。其中<code>||w||</code>表示w的二范数，求所有元素的平方和，然后再开方。比如对于二维平面：</p><p><img src="https://img-blog.csdn.net/20170923171706926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>那么，</p><p><img src="https://img-blog.csdn.net/20170923171733417?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>推广到多维不难理解，<strong>范数就是变量系数平方和再开根号</strong></li><li>接下来要解决的就是求距离最大值了</li></ul><h2 id="两个难题"><a class="markdownIt-Anchor" href="#两个难题"></a> 两个难题</h2><ul><li>如何判断决策面能够比较好地将两类分开完全呢</li><li>如何找到距离决策面最近地两点呢</li></ul><p>也就是说，为了能够实现上面地分类，我们必须先找到一条直线，能够对数据进行正确地分类，这是最基本地要求，然后在已经分类好地条件下，找到距离决策面最近地几个点，调整决策面位置，使他们的距离到最大。(找到最优解)</p><h2 id="问题的解决思路"><a class="markdownIt-Anchor" href="#问题的解决思路"></a> 问题的解决思路</h2><p>这个二维平面上有两种点，我们分别对它们进行标记：</p><ul><li>红颜色的圆点标记为1，我们人为规定其为正样本；</li><li>蓝颜色的五角星标记为-1，我们人为规定其为负样本。</li></ul><h3 id="获得约束条件"><a class="markdownIt-Anchor" href="#获得约束条件"></a> 获得约束条件</h3><p>对每个样本点xi加上一个类别标签yi：</p><p><img src="https://img-blog.csdn.net/20170923171905897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li><strong>首先，我们要对不同样本点进行标签分类，为了后面方便计算，我们在这里将数据分成-1和1两类</strong></li></ul><p><img src="https://img-blog.csdn.net/20170923171933138?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li><strong>平面上的所有点肯定是满足这个不等式的，即-1类的点，肯定在决策面的一边</strong></li></ul><p><strong>现在将条件变得更苛刻一些，即点到直线的距离，都是大于间隔<code>d</code>的</strong></p><p><img src="https://img-blog.csdn.net/20170923172000544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>式两边都除以d，就可以得到：</p><p><img src="https://img-blog.csdn.net/20170923172027169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>其中：</p><p><img src="https://img-blog.csdn.net/20170923172051319?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>让我们对<code>wd</code>和<code>γd</code>重新起个名字，就叫它们<code>w</code>和<code>γ</code>。因此，我们就可以说：”对于存在分类间隔的两类样本点，我们一定可以找到一些超平面面，使其对于所有的样本点均满足下面的条件：”</p><p><img src="https://img-blog.csdn.net/20171030230804176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>这个就是我们的约束条件，就是将点区分开来需要满足的条件，也就是说，如果我找到了一个决策面，不满足这个条件，那么这个决策面就是错误的</li></ul><p>进一步地，我们将约束条件写成：</p><p><img src="https://img-blog.csdn.net/20170923172259072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>因为<code>yi</code>只能取1或者-1，而由上面那个公式知道，负数乘负数依旧是正数</li></ul><h2 id="求目标函数"><a class="markdownIt-Anchor" href="#求目标函数"></a> 求目标函数</h2><p>前面我们知道目标函数，也就是关于距离<code>d</code>的方程</p><p><img src="https://img-blog.csdn.net/20170923172358421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p><strong>为了方便计算，我们先假设：任意支持向量上的点，到决策面的距离满足这条件</strong></p><p><img src="https://img-blog.csdn.net/20170923172456094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>进而将求d最大值问题化成了</p><p><img src="https://img-blog.csdn.net/20170923172524509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>要求d的最大值，转换成求w的最小值</li></ul><p>因为，我们只关心支持向量上的点。随后我们求解d的最大化问题变成了||w||的最小化问题。进而||w||的最小化问题等效于</p><p><img src="https://img-blog.csdn.net/20170923172617826?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>这样表示是为了后面好求导，而且w的极值和该函数取极值的点是一样的（平方不影响）</li></ul><p>我们将最终的目标函数和约束条件放在一起进行描述：</p><p><img src="https://img-blog.csdn.net/20170923172648006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><blockquote><p>缩写<code>s.t.</code>表示<code>”Subject to”，</code>是”服从某某条件”的意思。</p></blockquote><h2 id="对方程进行求解"><a class="markdownIt-Anchor" href="#对方程进行求解"></a> 对方程进行求解</h2><p>为了对方程进行求解，我们需要先了解下拉格朗日函数</p><p><img src="https://img-blog.csdn.net/20170923173128075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>满足这个条件的，都可以用拉格朗日函数求极值</li></ul><p><img src="https://img-blog.csdn.net/20170923172648006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>我们只需将上面第二个等式移项一下即可(左边移到右边)</li></ul><h3 id="拉格朗日对偶"><a class="markdownIt-Anchor" href="#拉格朗日对偶"></a> 拉格朗日对偶</h3><p>大概意思就是说，我们可以看到，要求下面函数的最小值，依旧比较困难，我们可以利用拉格朗日对偶将问题转换(最大值的最小值，转换成求最小值的最大值)</p><p><img src="https://img-blog.csdn.net/20170923172648006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>接着利用对应的数学公式，我们可以将问题转变成：</p><p><img src="https://img-blog.csdn.net/20170923174148322?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>首先固定α，要让L(w,b,α)关于w和b最小化，我们分别对w和b偏导数，令其等于0，即：</p><p><img src="https://img-blog.csdn.net/20170923174216260?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matplotlab</title>
    <link href="/2020/03/11/Matplotlab/"/>
    <url>/2020/03/11/Matplotlab/</url>
    
    <content type="html"><![CDATA[<h2 id="基本绘图"><a class="markdownIt-Anchor" href="#基本绘图"></a> 基本绘图</h2><ul><li><strong><code>pycham</code>中数据没法放大问题</strong></li></ul><blockquote><p>使用<code>pycharm</code>时我们经常会用<code>matplotlib</code>库画图并show出来，但在<code>pycharm</code>默认的设置中，其结果（如下图所示）是在<code>pycharm</code>的右侧展示，而且不能放大图片的任意位置，甚至鼠标滚轮放大后只能用滑动条去移动放大的图片。因此我们需要更改设置，设置路径：<code>file -&gt; settings -&gt; PythonScientific -&gt; 将Show plots in tool windo 的✔去掉</code></p></blockquote><ul><li><strong>无法显示中文问题</strong>，加入这两行代码即可</li></ul><blockquote><pre class="highlight"><code class="import">plt.rcParams['font.sans-serif'] = ['SimHei']  # 步骤一（替换sans-serif字体）plt.rcParams['axes.unicode_minus'] = False  # 步骤二（解决坐标轴负数的负号显示问题）</code></pre></blockquote><pre class="highlight"><code class="">import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1,1,50)y = 2*x + 1plt.plot(x, y)# 要画出来plt.show()# 画出来还要显示出来</code></pre><h2 id="绘制两个函数图像分别两个图"><a class="markdownIt-Anchor" href="#绘制两个函数图像分别两个图"></a> 绘制两个函数图像，分别两个图</h2><pre class="highlight"><code class="">x = np.linspace(-1,1,50)y1 = 2*x + 1y2 = x**2plt.figure()plt.plot(x, y1)plt.figure(num=3,figsize=(8, 5))plt.plot(x, y2)plt.show()</code></pre><ul><li><p>每个figure对应一个位置，结果是显示两个图片窗口</p></li><li><p>两个默认的参数<code>num=</code>,<code>figsize=()</code>，可以设置显示的窗口号，和图片的长宽</p></li></ul><h2 id="在一个图中画两个函数并设置颜色"><a class="markdownIt-Anchor" href="#在一个图中画两个函数并设置颜色"></a> 在一个图中画两个函数，并设置颜色</h2><pre class="highlight"><code class="">x = np.linspace(-1,1,50)y1 = 2*x + 1y2 = x**2plt.figure()plt.plot(x, y1)plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--')plt.show()</code></pre><ul><li><p>可以设置曲线的颜色等参数<code>color='red', linewidth=1.0, linestyle='--'</code></p></li><li><p><strong>要将两个曲线画在同一个窗口中，要记得只设置以一个figure()</strong></p></li></ul><h2 id="设置坐标轴取值范围限制显示范围"><a class="markdownIt-Anchor" href="#设置坐标轴取值范围限制显示范围"></a> 设置坐标轴取值范围(限制显示范围)</h2><ul><li><code>xlim(x limit),ylim</code></li></ul><pre class="highlight"><code class="">plt.figure()plt.plot(x, y1)plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--')plt.xlim(-0.5, 0.5)plt.ylim(-1, 1)plt.show()</code></pre><ul><li>注意一定要在figure和show之间设置<code>xlim</code></li></ul><h2 id="添加x轴或y轴的描述"><a class="markdownIt-Anchor" href="#添加x轴或y轴的描述"></a> 添加x轴或y轴的描述</h2><pre class="highlight"><code class="">plt.figure()plt.plot(x, y1)plt.xlabel('时间')plt.ylabel('number')plt.show()</code></pre><h2 id="更换xy轴的数据显示形式"><a class="markdownIt-Anchor" href="#更换xy轴的数据显示形式"></a> 更换x,y轴的数据显示形式</h2><ul><li><p><code>xticks()</code>,<code>yticks()</code></p></li><li><p>使用场景，给别人看时一目了然</p></li></ul><pre class="highlight"><code class="">plt.figure()plt.plot(x, y1)plt.xlabel('时间')plt.ylabel('number')plt.yticks(ticks=[-1,-0.5,0.5,1],           labels=['非常差','差','好','非常好']           )plt.show()</code></pre><pre class="highlight"><code class="">plt.figure()plt.plot(x, y1)plt.xlabel('时间')plt.ylabel('number')plt.yticks(ticks=[-1,-0.5,0.5,1],           labels=[r'$really\ bad$',r'$bad$',r'$normal$',r'$really\ good$']           )plt.show()</code></pre><ul><li><code>r</code>表示正则表达，两个美元符号表示以数学格式显示，更美观，空格要转义<code>\</code></li></ul><h2 id="制作图例"><a class="markdownIt-Anchor" href="#制作图例"></a> 制作图例</h2><ul><li>利用<code>label</code>属性，和<code>legend</code>方法</li></ul><pre class="highlight"><code class="">plt.figure()plt.plot(x, y1, label='y1')plt.plot(x, y2, label='y2')plt.legend()plt.show()</code></pre><h2 id="散点图绘制"><a class="markdownIt-Anchor" href="#散点图绘制"></a> 散点图绘制</h2><pre class="highlight"><code class="">n = 1024x = np.random.normal(0, 1, n)y = np.random.normal(0, 1, n)t = np.arctan2(y, x)# 为了颜色好看plt.scatter(x, y, s=20, c=t, alpha=0.5)# size colorplt.xticks(())# 不显示坐标plt.yticks(())plt.show()</code></pre><pre class="highlight"><code class="">x = np.arange(10)y = x**2plt.scatter(x, y)# 注意这里是先x后yplt.show()</code></pre><h2 id="用数组打印图片"><a class="markdownIt-Anchor" href="#用数组打印图片"></a> 用数组打印图片</h2><h3 id="随机数组可以用random生成"><a class="markdownIt-Anchor" href="#随机数组可以用random生成"></a> 随机数组可以用random生成</h3><p><a href="https://blog.csdn.net/weixin_44554475/article/details/93486481" target="_blank" rel="noopener">看这里介绍</a></p><pre class="highlight"><code class="">a = np.random.random(size=(3, 3))plt.imshow(a)plt.colorbar()plt.show()</code></pre><ul><li>一定要用到<code>imshow</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pandas</title>
    <link href="/2020/03/10/pandas/"/>
    <url>/2020/03/10/pandas/</url>
    
    <content type="html"><![CDATA[<ul><li><p><strong>axis=0表示操作行，axis=1表示操作列</strong></p><p>pandas可以读取txt文件，使用pandas.read_table</p></li></ul><h2 id="pandas和numpy的区别"><a class="markdownIt-Anchor" href="#pandas和numpy的区别"></a> pandas和numpy的区别</h2><ul><li>numpy一般是处理数值型数据</li><li>pandas则可以处理c语言中结构体的数据，里面可以混合字符串和数值</li></ul><h2 id="series创建一维带标签的数组"><a class="markdownIt-Anchor" href="#series创建一维带标签的数组"></a> Series创建一维带标签的数组</h2><ul><li>语法：Series([list])</li></ul><pre class="highlight"><code class="">print(pd.Series([1,2,3,np.nan,8]))</code></pre><pre class="highlight"><code class="">0    1.01    2.02    3.03    NaN4    8.0dtype: float64</code></pre><ul><li>np.nan means NaN</li><li>Series开头一定要大写</li><li>默认存储的形式是float</li></ul><h3 id="series数据的索引"><a class="markdownIt-Anchor" href="#series数据的索引"></a> Series数据的索引</h3><h4 id="直接索引"><a class="markdownIt-Anchor" href="#直接索引"></a> 直接索引</h4><pre class="highlight"><code class="">t = pd.Series([1,2,3,np.nan,8], index=list('abcde'))print(t['b'])</code></pre><ul><li><strong>使用index属性，注意后面也要传入list数据类型</strong></li></ul><h4 id="利用数组索引多个"><a class="markdownIt-Anchor" href="#利用数组索引多个"></a> 利用数组索引多个</h4><pre class="highlight"><code class="">dict1 = {    1:&quot;abc&quot;,    &quot;adidas&quot;:&quot;to be&quot;,    '5':6}t = pd.Series(dict1)print(t[[1,'5']])</code></pre><pre class="highlight"><code class="">1    abc5      6dtype: object</code></pre><h4 id="切片索引下面会讲"><a class="markdownIt-Anchor" href="#切片索引下面会讲"></a> 切片索引(下面会讲)</h4><h4 id="布尔索引"><a class="markdownIt-Anchor" href="#布尔索引"></a> 布尔索引</h4><pre class="highlight"><code class="">t = pd.Series([2,3,4,1])print(t[t &gt; 2])</code></pre><pre class="highlight"><code class="">1    32    4dtype: int64</code></pre><ul><li>选中t中所有大于2的值</li></ul><h3 id="通过python字典和series创建一维标签数组"><a class="markdownIt-Anchor" href="#通过python字典和series创建一维标签数组"></a> 通过python字典和Series创建一维标签数组</h3><pre class="highlight"><code class="">dict1 = {    1:&quot;abc&quot;,    &quot;adidas&quot;:&quot;to be&quot;,    '5':6}t = pd.Series(dict1)print(t)</code></pre><pre class="highlight"><code class="">1           abcadidas    to be5             6dtype: object</code></pre><h3 id="修改series中的dtype"><a class="markdownIt-Anchor" href="#修改series中的dtype"></a> 修改Series中的dtype</h3><pre class="highlight"><code class="">u = pd.Series([1.2,2,3,4])print(u)print(u.dtype)print(u.astype(int))</code></pre><pre class="highlight"><code class="">0    1.21    2.02    3.03    4.0dtype: float64float640    11    22    33    4dtype: int32</code></pre><p>注意直接使用<code>u.astype(int)</code>不会改变u的类型(不会对u造成影响)</p><h3 id="series的切片"><a class="markdownIt-Anchor" href="#series的切片"></a> Series的切片</h3><pre class="highlight"><code class="">dict1 = {    1:&quot;abc&quot;,    &quot;adidas&quot;:&quot;to be&quot;,    '5':6}t = pd.Series(dict1)print(t[:2])</code></pre><pre class="highlight"><code class="">1           abcadidas    to bedtype: object</code></pre><h3 id="取出series中的标签"><a class="markdownIt-Anchor" href="#取出series中的标签"></a> 取出Series中的标签</h3><h4 id="利用index属性可以直接获得标签并可迭代获取每个标签"><a class="markdownIt-Anchor" href="#利用index属性可以直接获得标签并可迭代获取每个标签"></a> 利用index属性，可以直接获得标签，并可迭代获取每个标签</h4><pre class="highlight"><code class="">t = pd.Series([2,3,4,1])print(t.index)for i in t.index:    print(i)</code></pre><pre class="highlight"><code class="">RangeIndex(start=0, stop=4, step=1)0123</code></pre><ul><li>还可以对index进行切片</li></ul><pre class="highlight"><code class="">t = pd.Series([2,3,4,1])print(t.index[1:])</code></pre><pre class="highlight"><code class="">RangeIndex(start=1, stop=4, step=1)</code></pre><h3 id="取出series中的values"><a class="markdownIt-Anchor" href="#取出series中的values"></a> 取出Series中的values</h3><pre class="highlight"><code class="">t = pd.Series([2,3,4,1])print(t.values)</code></pre><ul><li><strong>series本质就是带标签的数组，可以切片和迭代等操作</strong></li></ul><h3 id="读取或者保存数据"><a class="markdownIt-Anchor" href="#读取或者保存数据"></a> 读取或者保存数据</h3><h4 id="读取外部数据文件csvexceljsonpickle"><a class="markdownIt-Anchor" href="#读取外部数据文件csvexceljsonpickle"></a> 读取外部数据文件(csv,excel,json,pickle)</h4><pre class="highlight"><code class="">path = r'C:\Users\asus\Desktop\usePydealdata\pydata-book\datasets\fec\P00000001-ALL.csv'result = pd.read_csv(path)print(result)</code></pre><ul><li>如果数据太多则会省略打印</li></ul><h4 id="数据的保存"><a class="markdownIt-Anchor" href="#数据的保存"></a> 数据的保存</h4><pre class="highlight"><code class="">result = pd.read_csv(path)result.to_csv('student.csv')</code></pre><ul><li>这样数据就会被保存为相应的格式，会生成到程序目录下</li></ul><h3 id="pandas的dataframe二维数据结构"><a class="markdownIt-Anchor" href="#pandas的dataframe二维数据结构"></a> pandas的DataFrame(二维数据结构)</h3><pre class="highlight"><code class="">t = np.arange(10).reshape((2, 5))print(pd.DataFrame(t))</code></pre><pre class="highlight"><code class="">   0  1  2  3  40  0  1  2  3  41  5  6  7  8  9</code></pre><ul><li>拥有行索引和列索引axis=1表示纵向索引</li></ul><h3 id="改变索引index改变行columns改变列"><a class="markdownIt-Anchor" href="#改变索引index改变行columns改变列"></a> 改变索引，index改变行，columns改变列</h3><pre class="highlight"><code class="">t = np.arange(10).reshape((2, 5))u = pd.DataFrame(t, index=list('ab'), columns=list('abcde'))print(u)</code></pre><pre class="highlight"><code class="">   a  b  c  d  ea  0  1  2  3  4b  5  6  7  8  9</code></pre><h3 id="引入字典创建二维列表"><a class="markdownIt-Anchor" href="#引入字典创建二维列表"></a> 引入字典创建二维列表</h3><pre class="highlight"><code class="">dict1 = {'name':['baba', 'mama'], 'age':[44,41],'sex':['male','female']}print(pd.DataFrame(dict1))</code></pre><pre class="highlight"><code class="">   name  age     sex0  baba   44    male1  mama   41  female</code></pre><ul><li><strong>注意字典的键要对应一个数组</strong></li></ul><pre class="highlight"><code class="">list2 = [{'name':&quot;baba&quot;,'age':44,'tel':10086},{&quot;name&quot;:'mama','age':41,'tel':10086}]print(pd.DataFrame(list2))</code></pre><pre class="highlight"><code class="">   name  age    tel0  baba   44  100861  mama   41  10086</code></pre><ul><li>列表可以存放字典，来生成二维数组</li></ul><pre class="highlight"><code class="">list2 = [{'name':&quot;baba&quot;,'age':44,'tel':10086},{'age':41,'tel':10086}]print(pd.DataFrame(list2))</code></pre><pre class="highlight"><code class="">   name  age    tel0  baba   44  100861   NaN   41  10086</code></pre><ul><li><strong>pandas会把字典的所有键生成列的标签</strong></li></ul><pre class="highlight"><code class="">dict1 = {'name':['baba', 'mama'], 'age':[44,41],'sex':['male','female']}dict2 = {'name':['a', 'b'], 'age':[44,41],'sex':['male','female']}list1 = [dict1, dict2]print(pd.DataFrame(list1))</code></pre><pre class="highlight"><code class="">           name       age             sex0  [baba, mama]  [44, 41]  [male, female]1        [a, b]  [44, 41]  [male, female]</code></pre><h3 id="dataframe的属性"><a class="markdownIt-Anchor" href="#dataframe的属性"></a> DataFrame的属性</h3><ul><li>index，columns</li></ul><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t.index)print(t.columns)</code></pre><pre class="highlight"><code class="">RangeIndex(start=0, stop=2, step=1)Index(['a', 'b', 'c', 'd'], dtype='object')</code></pre><ul><li>values</li></ul><pre class="highlight"><code class="">[[1 2 3 4] [2 3 4 5]]</code></pre><ul><li>describe计算每个维度的平均值等</li></ul><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t.describe())</code></pre><pre class="highlight"><code class="">              a         b         c         dcount  2.000000  2.000000  2.000000  2.000000mean   1.500000  2.500000  3.500000  4.500000std    0.707107  0.707107  0.707107  0.707107min    1.000000  2.000000  3.000000  4.00000025%    1.250000  2.250000  3.250000  4.25000050%    1.500000  2.500000  3.500000  4.50000075%    1.750000  2.750000  3.750000  4.750000max    2.000000  3.000000  4.000000  5.000000</code></pre><ul><li>二维数组的转置.T</li></ul><pre class="highlight"><code class="">   0  1a  1  2b  2  3c  3  4d  4  5</code></pre><ul><li>排序sort_index(axis=,ascending=False)</li></ul><blockquote><ul><li><p>ascending表示升序,如果不设置这个值，则默认升序，设置了后，则是倒序</p></li><li><p>axis=0则是对行进行排序，axis=1则是对列进行排序</p></li></ul></blockquote><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))u = t.sort_index(axis=0,ascending=False)print(u)</code></pre><pre class="highlight"><code class="">   a  b  c  d1  2  3  4  50  1  2  3  4</code></pre><ul><li>sort_valuse(by=,ascending=False)</li></ul><blockquote><p>可以指定通过哪一列进行排序</p></blockquote><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))u = t.sort_values(by='b',ascending=False)print(u)</code></pre><pre class="highlight"><code class="">   a  b  c  d1  2  3  4  50  1  2  3  4</code></pre><h3 id="索引dataframe的行或者列"><a class="markdownIt-Anchor" href="#索引dataframe的行或者列"></a> 索引DataFrame的行或者列</h3><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t)print('-----------')print(t.a)print(t['b'])print('-----------')print(t[0:1])print('-----------')#print(t[1])</code></pre><pre class="highlight"><code class="">   a  b  c  d0  1  2  3  41  2  3  4  5-----------0    11    2Name: a, dtype: int640    21    3Name: b, dtype: int64-----------   a  b  c  d0  1  2  3  4-----------</code></pre><ul><li><p><strong><code>print(t[1])</code>is wrong use <code>print(t[1:])</code> instead</strong></p></li><li><p><strong>loc[]方法</strong>,注意后面不是()(把loc看成一个二维矩阵就好理解啦)</p></li></ul><blockquote><ul><li>下面程序是打印某一行的数据</li></ul></blockquote><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t)print(t.loc[0])print(t.loc[1])</code></pre><pre class="highlight"><code class="">   a  b  c  d0  1  2  3  41  2  3  4  5a    1b    2c    3d    4Name: 0, dtype: int64a    2b    3c    4d    5Name: 1, dtype: int64</code></pre><blockquote><ul><li>下面是指定打印某一列的数据</li></ul></blockquote><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t)print(t.loc[:,['a','b']])</code></pre><pre class="highlight"><code class="">   a  b  c  d0  1  2  3  41  2  3  4  5   a  b0  1  21  2  3</code></pre><pre class="highlight"><code class="">print(t.loc[0,['a','b']])</code></pre><pre class="highlight"><code class="">a    1b    2Name: 0, dtype: int64</code></pre><ul><li>iloc[index，columns]，按位置索引</li></ul><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t)print(t.iloc[0,1:2])#第0行第一个元素print(t.iloc[0,:])</code></pre><pre class="highlight"><code class="">   a  b  c  d0  1  2  3  41  2  3  4  5b    2Name: 0, dtype: int64a    1b    2c    3d    4Name: 0, dtype: int64</code></pre><blockquote><p>如果想不连续挑选某些值</p></blockquote><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t)print(t.iloc[0,[1,3]])#这里不能用标签进行筛选</code></pre><pre class="highlight"><code class="">   a  b  c  d0  1  2  3  41  2  3  4  5b    2d    4Name: 0, dtype: int64</code></pre><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t)print(t.loc[0,['a','d']])#可以使用loc进行筛选</code></pre><pre class="highlight"><code class="">   a  b  c  d0  1  2  3  41  2  3  4  5a    1d    4Name: 0, dtype: int64</code></pre><h3 id="布尔运算进行筛选"><a class="markdownIt-Anchor" href="#布尔运算进行筛选"></a> 布尔运算进行筛选</h3><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t)print(t.a &gt; 1)#这样只是对a列进行筛选print(t[t.a &gt; 1])#这样还可以打印abcd四个标签</code></pre><pre class="highlight"><code class="">   a  b  c  d0  1  2  3  41  2  3  4  50    False1     TrueName: a, dtype: bool   a  b  c  d1  2  3  4  5</code></pre><h3 id="更改数组中的值"><a class="markdownIt-Anchor" href="#更改数组中的值"></a> 更改数组中的值</h3><ul><li><strong>按位置进行修改iloc</strong></li></ul><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))t.iloc[1,2] = 22print(t)</code></pre><pre class="highlight"><code class="">   a  b   c  d0  1  2   3  41  2  3  22  5</code></pre><ul><li><strong>按标签进行修改</strong></li></ul><blockquote><p><strong>如果没有某个值，则会自动添加，改变原始数据</strong></p></blockquote><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))t.loc[1,2] = 22print(t)t.loc[1,'b'] = 33print(t)</code></pre><pre class="highlight"><code class="">   a  b  c  d     20  1  2  3  4   NaN1  2  3  4  5  22.0   a   b  c  d     20  1   2  3  4   NaN1  2  33  4  5  22.0</code></pre><ul><li><strong>修改某一列或某一行的所有值</strong></li></ul><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t)t.loc[:,'a'] = 55print(t)t.loc[0,:] = 0print(t)</code></pre><pre class="highlight"><code class="">   a  b  c  d0  1  2  3  41  2  3  4  5    a  b  c  d0  55  2  3  41  55  3  4  5    a  b  c  d0   0  0  0  01  55  3  4  5</code></pre><ul><li><strong>修改满足某一条件的值</strong></li></ul><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))print(t)t[t.a &gt; 1] = 0#将所有的列改print(t)t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))t.a[t.a &gt; 1] = 0#将某一列进行修改print(t)</code></pre><pre class="highlight"><code class="">   a  b  c  d0  1  2  3  41  2  3  4  5   a  b  c  d0  1  2  3  41  0  0  0  0   a  b  c  d0  1  2  3  41  0  3  4  5</code></pre><h3 id="给数据加某一列并且赋值"><a class="markdownIt-Anchor" href="#给数据加某一列并且赋值"></a> 给数据加某一列并且赋值</h3><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))t['e'] = np.nanprint(t)</code></pre><pre class="highlight"><code class="">   a  b  c  d   e0  1  2  3  4 NaN1  2  3  4  5 NaN</code></pre><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))t['e'] = np.nant['f'] = pd.Series([33,34])#t['f'] = 1print(t)</code></pre><pre class="highlight"><code class="">   a  b  c  d   e   f0  1  2  3  4 NaN  331  2  3  4  5 NaN  34</code></pre><ul><li>加上一样的值或者是不一样的值都行</li></ul><h3 id="处理丢失的数据"><a class="markdownIt-Anchor" href="#处理丢失的数据"></a> 处理丢失的数据</h3><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))t.iloc[0,1] = np.nanprint(t)print('---------')u = t.dropna(axis=0,how='any')#how={'any','all'}print(u)</code></pre><pre class="highlight"><code class="">   a    b  c  d0  1  NaN  3  41  2  3.0  4  5---------   a    b  c  d1  2  3.0  4  5</code></pre><ul><li><p>axis=0表示处理行的数据，=1表示处理列，默认是处理行</p></li><li><p>当how=‘any’时，则只要行数据中有NaN，则会删除这行，<strong>all是必须所有数据都为NaN才会删除</strong></p></li><li><p>注意不会对原先的数组造成影响</p></li></ul><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))t.iloc[0,1] = np.nanprint(t)print('---------')u = t.fillna(value=0)print(u)</code></pre><pre class="highlight"><code class="">   a    b  c  d0  1  NaN  3  41  2  3.0  4  5---------   a    b  c  d0  1  0.0  3  41  2  3.0  4  5</code></pre><ul><li>给所有NaN填上数据</li></ul><h3 id="检查数据是否有丢失npanyisnull"><a class="markdownIt-Anchor" href="#检查数据是否有丢失npanyisnull"></a> 检查数据是否有丢失np.any(),isnull()</h3><pre class="highlight"><code class="">t = pd.DataFrame([[1,2,3,4],[2,3,4,5]],columns=list('abcd'))u = np.any((t.isnull()))print(u)print('---------')t.iloc[0,1] = np.nanprint(t)print('---------')print(t.isnull())print('---------')u = np.any((t.isnull()))print(u)</code></pre><pre class="highlight"><code class="">False---------   a    b  c  d0  1  NaN  3  41  2  3.0  4  5---------       a      b      c      d0  False   True  False  False1  False  False  False  False---------True</code></pre><h2 id="合并多个dataframe"><a class="markdownIt-Anchor" href="#合并多个dataframe"></a> 合并多个DataFrame</h2><h4 id="concat"><a class="markdownIt-Anchor" href="#concat"></a> concat()</h4><pre class="highlight"><code class="">array1 = np.ones((3,4))*0array2 = np.ones((3,4))array3 = np.ones((3,4))*2df1 = pd.DataFrame(array1, columns=list('abcd'))df2 = pd.DataFrame(array2, columns=list('abcd'))df3 = pd.DataFrame(array3, columns=list('abcd'))print(pd.concat([df1,df2,df3],axis=0))</code></pre><pre class="highlight"><code class="">     a    b    c    d0  0.0  0.0  0.0  0.01  0.0  0.0  0.0  0.02  0.0  0.0  0.0  0.00  1.0  1.0  1.0  1.01  1.0  1.0  1.0  1.02  1.0  1.0  1.0  1.00  2.0  2.0  2.0  2.01  2.0  2.0  2.0  2.02  2.0  2.0  2.0  2.0</code></pre><ul><li>axis表示选择操作方向，=0表示操作行，也就是行与行之间合并</li><li>因为abcd属性是一样的，所以这里不适合操作列</li></ul><pre class="highlight"><code class="">print(pd.concat([df1,df2,df3], axis=0, ignore_index=True))</code></pre><pre class="highlight"><code class="">     a    b    c    d0  0.0  0.0  0.0  0.01  0.0  0.0  0.0  0.02  0.0  0.0  0.0  0.03  1.0  1.0  1.0  1.04  1.0  1.0  1.0  1.05  1.0  1.0  1.0  1.06  2.0  2.0  2.0  2.07  2.0  2.0  2.0  2.08  2.0  2.0  2.0  2.0</code></pre><h4 id="数据取交集部分合并"><a class="markdownIt-Anchor" href="#数据取交集部分合并"></a> 数据取交集部分合并</h4><ul><li>现在假设我们要将该数据进行合并</li></ul><pre class="highlight"><code class="">     a    b    c    d0  0.0  0.0  0.0  0.01  0.0  0.0  0.0  0.02  0.0  0.0  0.0  0.0     b    c    d    e0  1.0  1.0  1.0  1.01  1.0  1.0  1.0  1.02  1.0  1.0  1.0  1.0</code></pre><pre class="highlight"><code class="">print(pd.concat([df1,df2], axis=0, ignore_index=True))</code></pre><pre class="highlight"><code class="">     a    b    c    d    e0  0.0  0.0  0.0  0.0  NaN1  0.0  0.0  0.0  0.0  NaN2  0.0  0.0  0.0  0.0  NaN3  NaN  1.0  1.0  1.0  1.04  NaN  1.0  1.0  1.0  1.05  NaN  1.0  1.0  1.0  1.0</code></pre><blockquote><p><strong>直接合并后发现两者都没有的部分变成了NaN</strong></p></blockquote><ul><li>使用join属性，可以取两者数据交集进行合并,默认是outer模式</li></ul><pre class="highlight"><code class="">print(pd.concat([df1,df2], axis=0, ignore_index=True, join='inner'))</code></pre><pre class="highlight"><code class="">     b    c    d0  0.0  0.0  0.01  0.0  0.0  0.02  0.0  0.0  0.03  1.0  1.0  1.04  1.0  1.0  1.05  1.0  1.0  1.0</code></pre><pre class="highlight"><code class="">df1 = pd.DataFrame(array1, columns=list('abcd'), index=[1,2,3])df2 = pd.DataFrame(array2, columns=list('bcde'), index=[0,1,2])print(pd.concat([df1,df2], axis=1, ignore_index=True))</code></pre><pre class="highlight"><code class="">     0    1    2    3    4    5    6    70  NaN  NaN  NaN  NaN  1.0  1.0  1.0  1.01  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.02  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.03  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN</code></pre><ul><li>会出现和上面类似的情况，这时候用join_axis=[]</li></ul><pre class="highlight"><code class="">df1 = pd.DataFrame(array1, columns=list('abcd'), index=[1,2,3])df2 = pd.DataFrame(array2, columns=list('bcde'), index=[0,1,2])print(pd.concat([df1,df2], join_axes=[df1.index], axis=1))</code></pre><pre class="highlight"><code class="">     a    b    c    d    b    c    d    e1  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.02  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.03  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN</code></pre><blockquote><p><strong>这样会按照df1的index进行合并</strong></p></blockquote><h3 id="append合并数据可以逐行添加"><a class="markdownIt-Anchor" href="#append合并数据可以逐行添加"></a> append合并数据,可以逐行添加</h3><pre class="highlight"><code class="">df1 = pd.DataFrame(array1, columns=list('abcd'), index=[1,2,3])df2 = pd.DataFrame(array2, columns=list('bcde'), index=[0,1,2])print(df1.append(df2, ignore_index=True))</code></pre><pre class="highlight"><code class="">     a    b    c    d    e0  0.0  0.0  0.0  0.0  NaN1  0.0  0.0  0.0  0.0  NaN2  0.0  0.0  0.0  0.0  NaN3  NaN  1.0  1.0  1.0  1.04  NaN  1.0  1.0  1.0  1.05  NaN  1.0  1.0  1.0  1.0</code></pre><ul><li><p><code>df1.append([df2,df3], ignore_index=True, axis=1)</code></p></li><li><p><strong>如果要添加某一行</strong></p></li></ul><pre class="highlight"><code class="">df1 = pd.DataFrame(array1, columns=list('abcd'), index=[1,2,3])s1 = pd.Series([x*0 for x in range(4)], index=list('abcd'))print(df1.append(s1, ignore_index=True))</code></pre><pre class="highlight"><code class="">     a    b    c    d0  0.0  0.0  0.0  0.01  0.0  0.0  0.0  0.02  0.0  0.0  0.0  0.03  0.0  0.0  0.0  0.0</code></pre><h3 id="merge进行链接"><a class="markdownIt-Anchor" href="#merge进行链接"></a> merge进行链接</h3><ul><li>现在假设有这两个数组（我试的存在问题，到时候再学习）</li></ul><pre class="highlight"><code class="">     A    B    C  key0  0.0  0.0  0.0  0.01  0.0  0.0  0.0  0.02  0.0  0.0  0.0  0.0   key    C    D    E0    0  1.0  1.0  1.01    0  1.0  1.0  1.02    0  1.0  1.0  1.0</code></pre><pre class="highlight"><code class="">print(pd.merge(df1, df2, on='key'))</code></pre><h2 id="数据的可视化"><a class="markdownIt-Anchor" href="#数据的可视化"></a> 数据的可视化</h2>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>logical regression</title>
    <link href="/2020/03/09/logical-regression/"/>
    <url>/2020/03/09/logical-regression/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是回归"><a class="markdownIt-Anchor" href="#什么是回归"></a> 什么是回归</h2><p>最简单的回归就是用一条的曲线，来拟合所有的数值，这个点要尽可能离所有点都比较接近，用求和来计算</p><h2 id="逻辑回归"><a class="markdownIt-Anchor" href="#逻辑回归"></a> 逻辑回归</h2><p>机器学习中的逻辑回归是用来分类的，而不是进行拟合的，利用回归来画出边界，进行分类</p><h2 id="sigmoid函数"><a class="markdownIt-Anchor" href="#sigmoid函数"></a> Sigmoid函数</h2><p><code>Sigomoid</code>函数看上去就像阶跃函数一样，但是阶跃函数在跳跃点处不好把握，所以找了它来替代（可以将任何输入，不论<code>x</code>范围是多少，都可以映射到0-1区间，<code>y</code>输出为0-1）</p><p><img src="https://img-blog.csdn.net/20170830195915704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>z值其实是每个特征量，也就是没给自变量，乘以一个系数，再求和得出，因此，我们需要得到如何计算最佳回归系数</li></ul><p><img src="https://img-blog.csdn.net/20170830200052982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p><img src="https://img-blog.csdn.net/20170830195855344?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>用矩阵表示就是这样，<code>x</code>表示输入的数据，<code>θ</code>表示最佳参数</li></ul><h2 id="梯度下降法"><a class="markdownIt-Anchor" href="#梯度下降法"></a> 梯度下降法</h2><p>我们先看个简单的求极大值的例子。一个看了就会想到高中生活的函数：</p><p><img src="https://img-blog.csdn.net/20170830200337262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>来吧，做高中题。这个函数的极值怎么求？显然这个函数开口向下，存在极大值，它的函数图像为：</p><p><img src="https://img-blog.csdn.net/20170830200401362?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>求极值，先求函数的导数：</p><p><img src="https://img-blog.csdn.net/20170831221629911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>令导数为0，可求出x=2即取得函数f(x)的极大值。极大值等于f(2)=4</p><p>但是真实环境中的函数不会像上面这么简单，就算求出了函数的导数，也很难精确计算出函数的极值。此时我们就可以用迭代的方法来做。就像爬坡一样，一点一点逼近极值。这种寻找最佳拟合参数的方法，就是最优化算法。爬坡这个动作用数学公式表达即为：</p><p><img src="https://img-blog.csdn.net/20170830200457026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><ul><li>导数就是<code>tanα</code>乘一个系数就相当于不断向前前进</li></ul><p>其中，α为步长，也就是学习速率，控制更新的幅度。效果如下图所示：</p><p><img src="https://img-blog.csdn.net/20170830200522945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>比如从(0,0)开始，迭代路径就是1-&gt;2-&gt;3-&gt;4-&gt;…-&gt;n，直到求出的x为函数极大值的近似值，停止迭代。</p><blockquote><p>寻找最优解其实还有很多算法，比如蚁群算法，遗传算法等，但是这些算法只能寻找单一目标，所以现在就有了多目标算法（就像我找工作，我想找那种钱多的，轻松的…）</p></blockquote><ul><li>梯度上升法是用来寻找最大值的，而梯度下降法是寻找最小值的</li></ul><h2 id="参考博客"><a class="markdownIt-Anchor" href="#参考博客"></a> 参考博客</h2><p><a href="https://blog.csdn.net/c406495762/article/details/77723333" target="_blank" rel="noopener">https://blog.csdn.net/c406495762/article/details/77723333</a></p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>从上图可以看出数据的分布情况。假设Sigmoid函数的输入记为z，那么z=w0x0 + w1x1 + w2x2，即可将数据分割开。其中，x0为全是1的向量，x1为数据集的第一列数据，x2为数据集的第二列数据。另z=0，则0=w0 + w1x1 + w2x2。横坐标为x1，纵坐标为x2。这个方程未知的参数为w0，w1，w2，也就是我们需要求的回归系数(最优参数)。</p><p>为什么x0可以等于1呢？</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习网站或工具推荐</title>
    <link href="/2020/03/08/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E6%88%96%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <url>/2020/03/08/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E6%88%96%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h2 id="markdown插入公式"><a class="markdownIt-Anchor" href="#markdown插入公式"></a> markdown插入公式</h2><ul><li>markdown支持Latex插入数学公式的使用符号&amp;&amp;，推荐一个在线输入公式，然后会转换成Latex的网站<a href="http://www.wiris.com/editor/demo/en/developers#mathml-latex" target="_blank" rel="noopener">click here</a>,网页加载可能有点慢，耐心等待下</li><li>由于博客传公式会出现问题，结合上面那个网站，再利用<a href="https://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">Latex转图片网站</a></li></ul><h2 id="机器学习书籍和网站"><a class="markdownIt-Anchor" href="#机器学习书籍和网站"></a> 机器学习书籍和网站</h2><ul><li>书籍《机器学习实战》，一个人拿着锄头那本书，<a href="https://www.manning.com/books/machine-learning-in-action" target="_blank" rel="noopener">源代码和数据地址</a>下载</li><li>由于书上机器学习代码是python2，运行起来会报错，<a href="https://github.com/Jack-Cherish/Machine-Learning" target="_blank" rel="noopener">推荐GitHub上代码</a></li><li>机器学习和深度学习<ul><li><a href="https://github.com/Miki123-gif/DeepLearning-500-questions" target="_blank" rel="noopener">(GitHub教程1)</a>机器学习500问，包含机器学习和深度学习，以及数学知识</li><li><a href="https://github.com/apachecn/AiLearning" target="_blank" rel="noopener">(Github教程2)</a>ailearning，教程主要是机器学习</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习网站推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网站推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贝叶斯分析</title>
    <link href="/2020/03/08/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E6%9E%90/"/>
    <url>/2020/03/08/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<ul><li>贝叶斯分析的核心就是，假如有一个数据，我要测试他是属于哪一类的，分别概率为<code>p1，p2，p3</code>，将会挑选概率最大的那个类别</li><li>贝叶斯准则，告诉我们，如果已知从盒子b中取出一块石头的概率，那么我们就可以按照概率公式算出，取出的一块石头，是来自盒子b的概率</li><li>朴素贝叶斯要求，各个特征是独立的，常用到是不是垃圾文件</li></ul><h2 id="大数定律"><a class="markdownIt-Anchor" href="#大数定律"></a> 大数定律</h2><p>当一个实验重复多次时（大量次数），事件发生的频率就会接近于概率</p><h2 id="先验信息"><a class="markdownIt-Anchor" href="#先验信息"></a> 先验信息</h2><p>就是我们对一个事件的发生需要有一定的认识，或者积累的经验</p><blockquote><ul><li><p>比如扔骰子，我们知道每个点朝上的概率是1/6，如果叫一个原始人来猜，他可能连数字都不知道是什么</p></li><li><p>比如蒙上一个人的眼睛，让他品尝分辨当前喝的是牛奶还是茶，它可以猜对，但是叫原始人来喝，他即使喝的是牛奶，他也不知道是牛奶，可能会猜茶</p></li><li><p>让一位音乐大师分辨曲子是哪个人写的，假如十个曲子5首是莫扎特的，音乐大师全都能才对，但是对一个没经验的人，概率就是百分之五十</p></li></ul></blockquote><hr /><blockquote><ul><li>古典统计学派认为概率来源于统计，需要通过统计来得到概率论（抛硬币）</li><li>贝叶斯学派认为有些概率来自于统计，有些则来自于先验知识</li><li>两者的矛盾主要是是否承认先验知识的存在</li></ul></blockquote><h2 id="贝叶斯定理"><a class="markdownIt-Anchor" href="#贝叶斯定理"></a> 贝叶斯定理</h2><p><strong>贝叶斯公式，只有一个特征时的公式</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">H</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">X</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mfrac><mrow><mi mathvariant="normal">P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">X</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">H</mi><mo stretchy="false">)</mo><mi mathvariant="normal">P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">H</mi><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">X</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\mathrm P(\mathrm H\vert\mathrm X)\;=\;\frac{\mathrm P(\mathrm X\vert\mathrm H)\mathrm P(\mathrm H)}{\mathrm P(\mathrm X)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathrm">P</span><span class="mopen">(</span><span class="mord mathrm">H</span><span class="mord">∣</span><span class="mord mathrm">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm">P</span><span class="mopen">(</span><span class="mord mathrm">X</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm">P</span><span class="mopen">(</span><span class="mord mathrm">X</span><span class="mord">∣</span><span class="mord mathrm">H</span><span class="mclose">)</span><span class="mord mathrm">P</span><span class="mopen">(</span><span class="mord mathrm">H</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">先</mi><mi mathvariant="normal">验</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow><mspace linebreak="newline"></mspace><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mrow><mi mathvariant="normal">特</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">先</mi><mi mathvariant="normal">验</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow><mspace linebreak="newline"></mspace><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>H</mi><mo stretchy="false">)</mo><mrow><mi mathvariant="normal">在</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow><mspace linebreak="newline"></mspace><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mrow><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">属</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow></mrow><annotation encoding="application/x-tex">P(H)\mathrm{表示垃圾邮件的先验概率}\\P(X)\mathrm{特定特征的先验概率}\\P(X\vert H)\mathrm{在垃圾邮件中包含特定特征的邮件的概率}\\P(H\vert X)\mathrm{包含特定特征的邮件属于垃圾邮件的概率}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">先</span><span class="mord cjk_fallback">验</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord"><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">先</span><span class="mord cjk_fallback">验</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord"><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord"><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span></span></span></span></p><blockquote><p>举例：假设现在有100封邮件，正常的有70，垃圾邮件有30，办证在正常邮件出现10次，在垃圾邮件中出现25次</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">假</mi><mi mathvariant="normal">设</mi></mrow><mi>X</mi><mrow><mi mathvariant="normal">为</mi><mi mathvariant="normal">办</mi><mi mathvariant="normal">证</mi></mrow><mi mathvariant="normal">，</mi><mi>H</mi><mrow><mi mathvariant="normal">为</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi></mrow><mspace linebreak="newline"></mspace><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">先</mi><mi mathvariant="normal">验</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow><mspace linebreak="newline"></mspace><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mrow><mi mathvariant="normal">特</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">办</mi><mi mathvariant="normal">证</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">先</mi><mi mathvariant="normal">验</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow><mspace linebreak="newline"></mspace><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>H</mi><mo stretchy="false">)</mo><mrow><mi mathvariant="normal">在</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi></mrow><mi mathvariant="normal">&quot;</mi><mrow><mi mathvariant="normal">办</mi><mi mathvariant="normal">证</mi></mrow><mi mathvariant="normal">&quot;</mi><mrow><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow><mspace linebreak="newline"></mspace><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mrow><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi></mrow><mi mathvariant="normal">&quot;</mi><mrow><mi mathvariant="normal">办</mi><mi mathvariant="normal">证</mi></mrow><mi mathvariant="normal">&quot;</mi><mrow><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">属</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{假设}X\mathrm{为办证}，H\mathrm{为垃圾邮件}\\P(H)\mathrm{表示垃圾邮件的先验概率}\\P(X)\mathrm{特定办证的先验概率}\\P(X\vert H)\mathrm{在垃圾邮件中包含}&quot;\mathrm{办证}&quot;\mathrm{特征的邮件的概率}\\P(H\vert X)\mathrm{包含}&quot;\mathrm{办证}&quot;\mathrm{特征的邮件属于垃圾邮件的概率}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord cjk_fallback">假</span><span class="mord cjk_fallback">设</span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">办</span><span class="mord cjk_fallback">证</span></span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord"><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">先</span><span class="mord cjk_fallback">验</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord"><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">办</span><span class="mord cjk_fallback">证</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">先</span><span class="mord cjk_fallback">验</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord"><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span></span><span class="mord">&quot;</span><span class="mord"><span class="mord cjk_fallback">办</span><span class="mord cjk_fallback">证</span></span><span class="mord">&quot;</span><span class="mord"><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord"><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span></span><span class="mord">&quot;</span><span class="mord"><span class="mord cjk_fallback">办</span><span class="mord cjk_fallback">证</span></span><span class="mord">&quot;</span><span class="mord"><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mn>30</mn><mi mathvariant="normal">/</mi><mn>100</mn><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mn>3</mn><mi mathvariant="normal">/</mi><mn>10</mn><mtext>  </mtext><mrow><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">现</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow><mspace linebreak="newline"></mspace><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mn>35</mn><mi mathvariant="normal">/</mi><mn>100</mn><mo separator="true">,</mo><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">办</mi><mi mathvariant="normal">证</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">体</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">现</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow><mi mathvariant="normal">（</mi><mrow><mi mathvariant="normal">包</mi><mi mathvariant="normal">括</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi></mrow><mi mathvariant="normal">）</mi><mspace linebreak="newline"></mspace><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>H</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mn>25</mn><mi mathvariant="normal">/</mi><mn>30</mn><mtext>  </mtext><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">办</mi><mi mathvariant="normal">证</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">邮</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">现</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi></mrow><mspace linebreak="newline"></mspace><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mn>5</mn><mi mathvariant="normal">/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">P(H)\;=\;30/100\;=\;3/10\;\mathrm{垃圾邮件出现的概率}\\P(X)\;=\;35/100,\mathrm{表示办证在整体出现的概率}（\mathrm{包括垃圾邮件}）\\P(X\vert H)\;=\;25/30\;\mathrm{表示办证在垃圾邮件中出现的概率}\\P(H\vert X)\;=\;5/7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">办</span><span class="mord cjk_fallback">证</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">体</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">括</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span></span><span class="mord cjk_fallback">）</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">/</span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">办</span><span class="mord cjk_fallback">证</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">邮</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">/</span><span class="mord">7</span></span></span></span></span></p></blockquote><p>包含办证的邮件，属于垃圾邮件的概率是5/7</p><blockquote><p><strong>我们假设特征之间 相互独立 。所谓 独立(independence) 指的是统计意义上的独立，即一个特征或者单词出现的可能性与它和其他单词相邻没有关系，比如说，“我们”中的“我”和“们”出现的概率与这两个字相邻没有任何关系。这个假设正是朴素贝叶斯分类器中 朴素(naive) 一词的含义。朴素贝叶斯分类器中的另一个假设是，每个特征同等重要。</strong></p></blockquote><h2 id="贝叶斯分析使用场景"><a class="markdownIt-Anchor" href="#贝叶斯分析使用场景"></a> 贝叶斯分析使用场景</h2><p>机器学习的一个重要应用就是文档的自动分类。</p><p>在文档分类中，整个文档（如一封电子邮件）是实例，而电子邮件中的某些元素则构成特征。我们可以观察文档中出现的词，并把每个词作为一个特征，而每个词的出现或者不出现作为该特征的值，这样得到的特征数目就会跟词汇表中的词的数目一样多。</p><p>朴素贝叶斯是上面介绍的贝叶斯分类器的一个扩展，是用于文档分类的常用算法。下面我们会进行一些朴素贝叶斯分类的实践项目。</p><p>某个医院早上来了六个门诊的病人，他们的情况如下表所示：</p><table><thead><tr><th>症状</th><th>职业</th><th>疾病</th></tr></thead><tbody><tr><td>打喷嚏</td><td>护士</td><td>感冒</td></tr><tr><td>打喷嚏</td><td>农夫</td><td>过敏</td></tr><tr><td>头痛</td><td>建筑工人</td><td>脑震荡</td></tr><tr><td>头痛</td><td>建筑工人</td><td>感冒</td></tr><tr><td>打喷嚏</td><td>教师</td><td>感冒</td></tr><tr><td>头痛</td><td>教师</td><td>脑震荡</td></tr></tbody></table><p>现在又来了第七个病人，是一个打喷嚏的建筑工人。请问他患上感冒的概率有多大？</p><p>根据贝叶斯定理：</p><p><img src="https://img-blog.csdn.net/20170817204750272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>可得：</p><p><img src="https://img-blog.csdn.net/20170817204812471?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>根据朴素贝叶斯条件独立性的假设可知，&quot;打喷嚏&quot;和&quot;建筑工人&quot;这两个特征是独立的，因此，上面的等式就变成了</p><p><img src="https://img-blog.csdn.net/20170817204834377?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>这里可以计算：</p><p><img src="https://img-blog.csdn.net/20170817204857275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p><p>因此，这个打喷嚏的建筑工人，有66%的概率是得了感冒。同理，可以计算这个病人患上过敏或脑震荡的概率。比较这几个概率，就可以知道他最可能得什么病。</p><p>这就是贝叶斯分类器的基本方法：在统计资料的基础上，依据某些特征，计算各个类别的概率，从而实现分类。</p><p>同样，在编程的时候，如果不需要求出所属类别的具体概率，P(打喷嚏) = 0.5和P(建筑工人) = 0.33的概率是可以不用求的。</p><h2 id="贝叶斯算法的优缺点"><a class="markdownIt-Anchor" href="#贝叶斯算法的优缺点"></a> 贝叶斯算法的优缺点</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>即使数据很少，依旧可以使用该算法</li><li>算法比较简单，主要是应用在对文章进行分类</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ul><li>由于需要知道先验概率，所以会引入人为误差</li><li>贝叶斯是假设数据的特征之间是独立的，然而在实际中很多特征的出现都是有联系的，这也会造成一定的误差</li><li>对输入的数据的类型要求比较高，我们先要将一篇文章的词语拆分，再去重，提取出来</li></ul><h2 id="参考博客"><a class="markdownIt-Anchor" href="#参考博客"></a> 参考博客</h2><p><a href="https://blog.csdn.net/c406495762/article/details/77341116" target="_blank" rel="noopener">https://blog.csdn.net/c406495762/article/details/77341116</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numpy的使用</title>
    <link href="/2020/03/08/numpy/"/>
    <url>/2020/03/08/numpy/</url>
    
    <content type="html"><![CDATA[<h1 id="numpy的用法"><a class="markdownIt-Anchor" href="#numpy的用法"></a> numpy的用法</h1><h2 id="使用notepad打开csv文件"><a class="markdownIt-Anchor" href="#使用notepad打开csv文件"></a> 使用notepad打开csv文件</h2><p>csv文件在电脑中默认是用excel打开的，最好使用记事本打开，因为用excel打开，会改变里面的数据，excel默认会用科学记数法表示一些很大的数。</p><ul><li><strong>注意numpy中对矩阵的各种运算都可以通过axis来指定是对行还是列运算，例如算mean等</strong></li></ul><h2 id="python中的矩阵"><a class="markdownIt-Anchor" href="#python中的矩阵"></a> python中的矩阵</h2><pre class="highlight"><code class="">matrix = [    [1,2,3],    [2,5,6]]print(matrix[1][2])'''answer = 6可以看出123为第一行'''</code></pre><p>但这样实际上还是列表，用array创建矩阵，没有逗号隔开的</p><pre class="highlight"><code class="">array = np.array([    [1,2,3],    [4,5,6],])print(array)'''输出：[[1 2 3] [4 5 6]]'''</code></pre><h3 id="获得矩阵的属性"><a class="markdownIt-Anchor" href="#获得矩阵的属性"></a> 获得矩阵的属性</h3><pre class="highlight"><code class=""># 把np的array类实例化array = np.array([    [1,2,3],    [4,5,6],    [0,0,0],])# 获得array的属性print('number of dim:', array.ndim)print('shape:', array.shape)print('size:', array.size)'''输出：#因为矩阵肯定是二维的，向量是一维的number of dim: 2shape: (3, 3)size: 9'''</code></pre><h2 id="dtype用法"><a class="markdownIt-Anchor" href="#dtype用法"></a> dtype用法</h2><pre class="highlight"><code class="">array = np.array([    [1.2,2,3],    [4,5,6],    [0,0,0],], dtype=np.int)#一定要是np.intprint(array)</code></pre><pre class="highlight"><code class="">[[1 2 3] [4 5 6] [0 0 0]]</code></pre><p>如果定义是int类型，则矩阵的所有元素都是整数类型</p><pre class="highlight"><code class="">array = np.array([    [1.2, 2, 3],    [4, 5, 6],    [0, 0, 0],], dtype=np.float32)print(array)</code></pre><ul><li>位数越小，则需要的内存越小</li></ul><h2 id="zeros创建0矩阵"><a class="markdownIt-Anchor" href="#zeros创建0矩阵"></a> zeros，创建0矩阵</h2><pre class="highlight"><code class="">print(np.zeros((3, 4)))</code></pre><pre class="highlight"><code class="">[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]</code></pre><ul><li>注意要用zeros，因为很多个0，<strong>同时函数里面还要用元组</strong></li></ul><h2 id="ones创建1矩阵"><a class="markdownIt-Anchor" href="#ones创建1矩阵"></a> ones，创建1矩阵</h2><pre class="highlight"><code class="">print(np.ones((3, 4), dtype=np.int))</code></pre><pre class="highlight"><code class="">[[1 1 1 1] [1 1 1 1] [1 1 1 1]]</code></pre><h2 id="arange创建与range类似的矩阵"><a class="markdownIt-Anchor" href="#arange创建与range类似的矩阵"></a> arange,创建与range类似的矩阵</h2><p><code>print(np.arange(0, 10, 2))</code>和python中的range是类似的</p><p>[0 2 4 6 8]</p><ul><li><p>arange中的reshape</p></li><li><p><code>print(np.arange(0, 12, 2).reshape((2, 3)))</code></p><pre class="highlight"><code class="">[[ 0  2  4] [ 6  8 10]]</code></pre></li><li><p>要注意0-12步长为2，里面是有6个元素的，所以2x3也必须是6</p></li></ul><h2 id="linspace生成步长序列"><a class="markdownIt-Anchor" href="#linspace生成步长序列"></a> linspace，生成步长序列</h2><pre class="highlight"><code class="">print(np.linspace(0, 5, 10).reshape((2, 5)))</code></pre><pre class="highlight"><code class="">[[0.         0.55555556 1.11111111 1.66666667 2.22222222] [2.77777778 3.33333333 3.88888889 4.44444444 5.        ]]</code></pre><p>从0到5，生成10个元素，逐渐增大</p><h2 id="矩阵的四则运算"><a class="markdownIt-Anchor" href="#矩阵的四则运算"></a> 矩阵的四则运算</h2><pre class="highlight"><code class="">a = np.arange(4)b = np.zeros(4)#加减乘除print(a + b)print('------------')print(a ** 2)</code></pre><pre class="highlight"><code class="">[0. 1. 2. 3.]------------[0 1 4 9]</code></pre><h2 id="矩阵的正弦余弦运算"><a class="markdownIt-Anchor" href="#矩阵的正弦余弦运算"></a> 矩阵的正弦余弦运算</h2><pre class="highlight"><code class="">a = np.arange(4)b = np.zeros(4)#正弦余弦运算print(np.cos(b))</code></pre><pre class="highlight"><code class="">[1. 1. 1. 1.]</code></pre><p>对每个元素求余弦</p><h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2><pre class="highlight"><code class="">a = np.arange(4)b = np.zeros(4)#逻辑运算print(a != 0)</code></pre><pre class="highlight"><code class="">[False  True  True  True]</code></pre><p>对每个元素进行逻辑运算，同时还有&gt;, &lt;, ==</p><h2 id="矩阵乘法和普通乘法运算"><a class="markdownIt-Anchor" href="#矩阵乘法和普通乘法运算"></a> 矩阵乘法和普通乘法运算</h2><pre class="highlight"><code class="">a = np.array([    [1,2],    [4,5]])b = np.array([    [0,1],    [0,1]])print(a*b)print(np.dot(a, b))</code></pre><pre class="highlight"><code class="">第一个是每个元素对应相乘第二个是矩阵乘法</code></pre><p><strong>两个向量相乘</strong></p><pre class="highlight"><code class="">a = np.arange(4).reshape((4, 1))b = np.arange(4).reshape((1, 4))print(np.dot(b, a))print(np.dot(a, b))print(b.dot(a))#两种表达形式，这种也行</code></pre><pre class="highlight"><code class="">[[14]][[0 0 0 0] [0 1 2 3] [0 2 4 6] [0 3 6 9]]</code></pre><h2 id="生成随机矩阵"><a class="markdownIt-Anchor" href="#生成随机矩阵"></a> 生成随机矩阵</h2><pre class="highlight"><code class="">a = np.random.random(2)#生成一维矩阵b = np.random.random((2,3))#生成二维矩阵</code></pre><pre class="highlight"><code class="">[0.66455362 0.09184438][[0.8223943  0.53069539 0.20177849] [0.45198285 0.64385535 0.48249845]]</code></pre><h2 id="求矩阵的最大最小或者求和"><a class="markdownIt-Anchor" href="#求矩阵的最大最小或者求和"></a> 求矩阵的最大最小，或者求和</h2><pre class="highlight"><code class="">a = np.random.random(2)#生成一维矩阵b = np.random.random((2,3))#生成二维矩阵print(np.max(a))print(a.max())print(np.min(b))print(np.sum(a))print(a.sum())</code></pre><pre class="highlight"><code class="">0.83471050813825130.135173229013998861.50803073066524181.5080307306652418</code></pre><pre class="highlight"><code class="">b = np.random.random((2,3))#生成二维矩阵print(b)print(b.min(axis=1))print(b.min(axis=0))</code></pre><pre class="highlight"><code class="">[[0.7780649  0.97145716 0.27643172] [0.06018098 0.29907257 0.83860847]][0.27643172 0.06018098][0.06018098 0.29907257 0.27643172]</code></pre><ul><li><p>当axis=0时，表示在每一列中找到最大值</p></li><li><p>当axis=1时，表示在每一行中找到最大值</p></li></ul><h2 id="找到最大值最小值的坐标argmin"><a class="markdownIt-Anchor" href="#找到最大值最小值的坐标argmin"></a> 找到最大值最小值的坐标argmin</h2><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))print(a)print(np.argmax(a))print(np.argmin(a))b = np.random.random((2,3))print('---------------')print(b)print(np.argmin(b))</code></pre><pre class="highlight"><code class="">[[0 1 2] [3 4 5]]50---------------[[0.26097962 0.65723894 0.01457888] [0.32926792 0.0782571  0.66194859]]2</code></pre><ul><li>还记得matlab吧，其实和他是差不多的，从左0开始不断往右数</li><li><strong>agrement表示的是自变量的意思</strong></li></ul><h2 id="计算矩阵的平均值mean中位数median"><a class="markdownIt-Anchor" href="#计算矩阵的平均值mean中位数median"></a> 计算矩阵的平均值mean，中位数median</h2><pre class="highlight"><code class="">print(a.mean())print(np.mean(a))print(np.median(a))</code></pre><pre class="highlight"><code class="">2.52.52.5</code></pre><h2 id="累加所有元素cumsum"><a class="markdownIt-Anchor" href="#累加所有元素cumsum"></a> 累加所有元素cumsum</h2><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))print(a)print(np.cumsum(a))</code></pre><pre class="highlight"><code class="">[[0 1 2] [3 4 5]][ 0  1  3  6 10 15]</code></pre><h2 id="累差diff两数之间的差值"><a class="markdownIt-Anchor" href="#累差diff两数之间的差值"></a> 累差diff,两数之间的差值</h2><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))print(a)print(np.diff(a))</code></pre><pre class="highlight"><code class="">[[0 1 2] [3 4 5]][[1 1] [1 1]]</code></pre><h2 id="输出所有非0的坐标nonzero"><a class="markdownIt-Anchor" href="#输出所有非0的坐标nonzero"></a> 输出所有非0的坐标nonzero</h2><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))print(a)print(np.nonzero(a))</code></pre><pre class="highlight"><code class="">[[0 1 2] [3 4 5]](array([0, 0, 1, 1, 1], dtype=int64), array([1, 2, 0, 1, 2], dtype=int64))</code></pre><p>左边表示行，右边表示列，如第0行1列是非0的</p><h2 id="矩阵的转置transpose"><a class="markdownIt-Anchor" href="#矩阵的转置transpose"></a> 矩阵的转置transpose</h2><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))print(a)print(np.transpose(a))print(a.T)#两种表示方式</code></pre><pre class="highlight"><code class="">[[0 1 2] [3 4 5]][[0 3] [1 4] [2 5]][[0 3] [1 4] [2 5]]</code></pre><h2 id="矩阵的逆i"><a class="markdownIt-Anchor" href="#矩阵的逆i"></a> 矩阵的逆.I</h2><h2 id="单位矩阵eye"><a class="markdownIt-Anchor" href="#单位矩阵eye"></a> 单位矩阵eye</h2><pre class="highlight"><code class="">data6 = np.mat(np.eye(2,2,dtype=int))print(data6)[[1 0] [0 1]]</code></pre><h2 id="对角矩阵diag"><a class="markdownIt-Anchor" href="#对角矩阵diag"></a> 对角矩阵diag</h2><pre class="highlight"><code class="">a1 = [1,2,3]a2 = np.mat(np.diag(a1))print(a2)'''[[1 0 0] [0 2 0] [0 0 3]]'''</code></pre><h2 id="clip让大于或小于某个值的值统一"><a class="markdownIt-Anchor" href="#clip让大于或小于某个值的值统一"></a> clip让大于或小于某个值的值统一</h2><p><strong>语法np.clip(matrix, min, max)</strong></p><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))print(a)print(np.clip(a,1,4))</code></pre><pre class="highlight"><code class="">[[0 1 2] [3 4 5]][[1 1 2] [3 4 4]]</code></pre><p>我们可以看到介于max和min之间的数值保留了</p><h2 id="矩阵的索引"><a class="markdownIt-Anchor" href="#矩阵的索引"></a> 矩阵的索引</h2><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))print(a)print(a[0][2])#打印第0行第2个元素print(a[0, 2])print(a[1])#打印第1行</code></pre><pre class="highlight"><code class="">[[0 1 2] [3 4 5]]2[3 4 5]</code></pre><ul><li>都是从0行0列开始的</li></ul><h3 id="打印某一行或某一列的所有元素"><a class="markdownIt-Anchor" href="#打印某一行或某一列的所有元素"></a> 打印某一行或某一列的所有元素</h3><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))print(a)print(a[:,0])print(a[1,:])</code></pre><pre class="highlight"><code class="">[[0 1 2] [3 4 5]][0 3][3 4 5]</code></pre><ul><li><code>理解了可以这样表达就很容易记了print(a[0, 2])</code></li></ul><blockquote><p>a[: , 1]表示第1列的所有元素，就像列表一样可以切片</p></blockquote><pre class="highlight"><code class="">print(a[1,:][1:2])</code></pre><p><code>[4]</code></p><ul><li>注意这个不是列表类型，而是矩阵类型，但依旧可以进行切片操作</li></ul><h2 id="for迭代矩阵每一行或每一列"><a class="markdownIt-Anchor" href="#for迭代矩阵每一行或每一列"></a> for迭代矩阵每一行或每一列</h2><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))for each in a:    print(each)print('---------')for each in a.T:    print(each)</code></pre><pre class="highlight"><code class="">[0 1 2][3 4 5]---------[0 3][1 4][2 5]</code></pre><ul><li>直接for循环是遍历每一行，转置下就是遍历每一列了</li></ul><h2 id="for遍历矩阵每一个元素flatten"><a class="markdownIt-Anchor" href="#for遍历矩阵每一个元素flatten"></a> for遍历矩阵每一个元素flatten()</h2><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))for each in a.flatten():    print(each)</code></pre><pre class="highlight"><code class="">012345</code></pre><pre class="highlight"><code class="">a = np.arange(0,6).reshape((2,3))print(a.flatten())#flatten就是转化成一维的for each in a.flat:#flat这里是一个迭代器，可以和yeilt和next使用    print(each)</code></pre><pre class="highlight"><code class="">[0 1 2 3 4 5]012345</code></pre><h2 id="多个矩阵的合并vstackhstack"><a class="markdownIt-Anchor" href="#多个矩阵的合并vstackhstack"></a> 多个矩阵的合并vstack，hstack</h2><h3 id="上下合并vstack"><a class="markdownIt-Anchor" href="#上下合并vstack"></a> 上下合并vstack</h3><ul><li>vstack表示vertical stack，上下堆积起来的意思</li><li><strong>注意vstack(())里面是元组</strong>,上下合并</li></ul><pre class="highlight"><code class="">a = np.array([1,2,3])b = np.array([4,5,6])print(np.vstack((a,b)))</code></pre><pre class="highlight"><code class="">[[1 2 3] [4 5 6]]</code></pre><h3 id="左右合并"><a class="markdownIt-Anchor" href="#左右合并"></a> 左右合并</h3><ul><li>hstack，horizontal stack</li></ul><pre class="highlight"><code class="">a = np.array([    [1],    [2],    [3],])b = np.array([    [2],    [3],    [4],])print(np.hstack((a,b)))</code></pre><pre class="highlight"><code class="">[[1 2] [2 3] [3 4]]</code></pre><h2 id="numpy中mat和array的区别重点"><a class="markdownIt-Anchor" href="#numpy中mat和array的区别重点"></a> numpy中mat和array的区别(重点)</h2><ul><li><strong>mat函数可以将其他类型的数据转换成矩阵类型，和matlab中的矩阵形式是一样的</strong></li></ul><pre class="highlight"><code class="">a = np.mat(np.ones((3,4)))print(type(a))print(type(np.zeros((3,4))))&lt;class 'numpy.matrix'&gt;&lt;class 'numpy.ndarray'&gt;#ndarray指的是存放同一数据类型的对象</code></pre><ul><li>mat矩阵赋值</li></ul><pre class="highlight"><code class="">a = np.mat([1,2,3],dtype=float)a[0] = 1.2print(a)[[1.2 1.2 1.2]]#会发现整个输出都变成了1.2，而转变成array却不会</code></pre><ul><li>mat生成矩阵有两种形式,而array只有一种形式</li></ul><pre class="highlight"><code class="">print(np.mat('1 2;3 4'))print(np.mat([[1,2],[3,4]]))</code></pre><pre class="highlight"><code class="">[[1 2] [3 4]][[1 2] [3 4]]</code></pre><ul><li><p>(1) mat()函数中矩阵的乘积可以使用（星号） *  或 .dot()函数，其结果相同。而矩阵对应位置元素相乘需调用numpy.multiply()函数。</p><p>(2) array()函数中矩阵的乘积只能使用 .dot()函数。而星号乘 （*）则表示矩阵对应位置元素相乘，与numpy.multiply()函数结果相同。</p></li><li><p><a href="https://www.jb51.net/article/156109.htm%EF%BC%8C%E8%AF%A6%E7%BB%86%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%BF%99%E4%B8%AA" target="_blank" rel="noopener">https://www.jb51.net/article/156109.htm，详细可以看这个</a></p></li><li><p>array如果生成一个行向量，转置后是不会得到一个列向量的，只有mat才会生成一个列向量</p></li></ul><h2 id="newaxis添加新的维度"><a class="markdownIt-Anchor" href="#newaxis添加新的维度"></a> newaxis添加新的维度</h2><pre class="highlight"><code class="">a = np.array([1,1,1])[:,np.newaxis]#这里只有一个括号[]print(a)</code></pre><pre class="highlight"><code class="">[[1] [1] [1]](3, 1)</code></pre><ul><li>相当于给每一个列添加新的维度</li><li><strong>注意，在调试的过程中，我想</strong></li></ul><pre class="highlight"><code class="">a = np.array([[1,1,1]])[:,np.newaxis],加了双[]，这样会失败，最后是变成了三个维度的张量</code></pre><h2 id="多个矩阵的合并concatenate"><a class="markdownIt-Anchor" href="#多个矩阵的合并concatenate"></a> 多个矩阵的合并concatenate</h2><ul><li>axis = 0， 相当于上下维度合并，相当于vstack</li><li>axis = 0，左右两个维度合并，相当于hstack</li></ul><h2 id="矩阵的分割"><a class="markdownIt-Anchor" href="#矩阵的分割"></a> 矩阵的分割</h2><h3 id="均匀分割splitmatrixnumaxis"><a class="markdownIt-Anchor" href="#均匀分割splitmatrixnumaxis"></a> 均匀分割split(matrix,num,axis=)</h3><pre class="highlight"><code class="">a = np.mat(np.ones((3,4)))b = np.split(a,2,axis=1)#axis=1表示对列进行操作1看起来就是一列print(b[0])print(b[1])[[1. 1.][1. 1.][1. 1.]][[1. 1.][1. 1.][1. 1.]]</code></pre><h3 id="不均匀分割arry_splitmatrixnumaxis"><a class="markdownIt-Anchor" href="#不均匀分割arry_splitmatrixnumaxis"></a> 不均匀分割arry_split(matrix,num,axis=)</h3><pre class="highlight"><code class="">a = np.mat(np.ones((3,4)))b = np.array_split(a,3,axis=1)print(b[0])print(b[1])</code></pre><h3 id="对行vsplitmatrixnum对列hspilitmatrixnum分割"><a class="markdownIt-Anchor" href="#对行vsplitmatrixnum对列hspilitmatrixnum分割"></a> 对行vsplit(matrix,num)，对列hspilit(matrix,num)分割</h3><pre class="highlight"><code class="">a = np.mat(np.ones((3,4)))print(np.vsplit(a, 3))#对行进行分割print(np.hsplit(a, 2))#对列进行分割</code></pre><pre class="highlight"><code class="">[matrix([[1., 1., 1., 1.]]), matrix([[1., 1., 1., 1.]]), matrix([[1., 1., 1., 1.]])][matrix([[1., 1.],        [1., 1.],        [1., 1.]]), matrix([[1., 1.],        [1., 1.],        [1., 1.]])]</code></pre><h2 id="矩阵的复制深复制浅复制"><a class="markdownIt-Anchor" href="#矩阵的复制深复制浅复制"></a> 矩阵的复制(深复制，浅复制)</h2><h3 id="浅复制"><a class="markdownIt-Anchor" href="#浅复制"></a> 浅复制</h3><pre class="highlight"><code class="">b = np.array([0,1,2],dtype=float)c = bb[0] = 0.3print(b)print(c)[0.3 1.  2. ][0.3 1.  2. ]</code></pre><h3 id="深复制copy"><a class="markdownIt-Anchor" href="#深复制copy"></a> 深复制copy</h3><pre class="highlight"><code class="">b = a.copy()</code></pre>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2020/03/07/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2020/03/07/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="决策树-decision-tree"><a class="markdownIt-Anchor" href="#决策树-decision-tree"></a> 决策树 decision tree</h2><blockquote><h4 id="信息熵-信息增益"><a class="markdownIt-Anchor" href="#信息熵-信息增益"></a> 信息熵 &amp; 信息增益</h4><ul><li><p>熵（entropy）： 熵指的是体系的混乱的程度，在不同的学科中也有引申出的更为具体的定义，是各领域十分重要的参量。</p></li><li><p>信息论（information theory）中的熵（香农熵）： 是一种信息的度量方式，表示信息的混乱程度，也就是说：信息越有序，信息熵越低。例如：火柴有序放在火柴盒里，熵值很低，相反，熵值很高。就像明天是晴天，和15天后是晴天，明天是晴天的熵是比较小的</p></li><li><p>信息增益（information gain）： 在划分数据集前后信息发生的变化称为信息增益。<strong>(目的就是将无需的信息变得有序)</strong>（一个随机变量，让另一个随机变量的熵减少了，一个变量对另一个变量的影响程度），例如是否贷款，我先假如年龄这个条件，再加入是否有工作这个条件，前者的熵明显会比后面的熵要大一些**（如果有没有工作，假如有工作对应可以贷款，没有工作对应不能贷款，那么有没有工作这个特征对贷款的信息增益是非常大的）**</p></li></ul></blockquote><blockquote><p>树的定义，就像族谱一样，根结点时唯一的，子树是根结点衍生出来的，当一个圈没叶子时，他就是叶结点，其他的都叫内部结点，如果一个内部结点有三片叶结点，那么这个内部结点的度就是3</p></blockquote><p>我们现在来看一个邮件分类系统，大致工作流程如下：</p><p><img src="https://camo.githubusercontent.com/7dcaa98439362b4e126996b04c039322c55894c9/687474703a2f2f646174612e617061636865636e2e6f72672f696d672f41694c6561726e696e672f6d6c2f332e4465636973696f6e547265652f2545352538362542332545372541442539362545362541302539312d2545362542352538312545372541382538422545352539422542452e6a7067" srcset="/img/loading.gif" alt="决策树-流程图" /></p><ul><li>根结点是发送的邮件域名地址</li><li>叶结点是：<ul><li>无聊时需要阅读的邮件</li><li>需要及时处理的朋友文件</li><li>无需阅读的垃圾邮件</li></ul></li><li>内部结点是：包含单词曲棍球的邮件</li></ul><p>在这个系统中，根结点相当于输入的数据，内部结点表示一个特征或属性(我觉得是判断条件)，叶结点相当于分类结果</p><p><strong>决策树一般是处理一些离散的数据，比如现在有一些年龄的数据，1-100岁之间，那么我们就必须将这些数据分为几个区间，比如0-30算年轻，30-60算中年，60-100算老年</strong></p><p><img src="https://camo.githubusercontent.com/161cc47ffb524fb353e53598a692cde423451499/687474703a2f2f646174612e617061636865636e2e6f72672f696d672f41694c6561726e696e672f6d6c2f332e4465636973696f6e547265652f2545372538362542352545372539412538342545382541452541312545372541452539372545352538352541432545352542432538462e6a7067" srcset="/img/loading.gif" alt="熵的计算公式" /></p><blockquote><p>信息熵的计算是，假如扔一个骰子，每个面朝上的概率都是1/6，那么prob就是1/6带进去，求和表示把所有情况都算出来再相加</p></blockquote><h2 id="决策树实战"><a class="markdownIt-Anchor" href="#决策树实战"></a> 决策树实战</h2><h3 id="判断是不是鱼"><a class="markdownIt-Anchor" href="#判断是不是鱼"></a> 判断是不是鱼</h3><p>决策树的关键之一就是计算信息熵</p><p>思路:</p><ul><li>先获取数据，将数据转换成0-1矩阵</li></ul><blockquote><p>如鱼类有鲤鱼，草鱼，鲇鱼，假如很多种，这样怎么用012表示呢？其实我们只要把所有种类写出，如果是这种鱼类则标记为1，不是则为0(算信息熵并不需要归一化)</p></blockquote><ul><li>为了计算信息熵，我们必须将所有可能的结果计算出来</li></ul><blockquote><p>利用for循环，和字典，统计每个标签(是不是鱼，yes-1，no-0)出现的次数，具体为，如果没有出现这个标签，则先将他添加进字典中，并赋值为1，循环后，再用每个标签出现的次数除以总的样本数就是概率，利用信息熵公式得到结果，标签种类越多，信息熵就会越大</p></blockquote><ul><li>计算信息增益，比如现在有两个特征，有没有工作，年龄(为什么有没有工作比较重要就是基于信息增益)，分类结果是是否要贷款，我们先计算是否贷款的信息熵，然后先更具年龄进行信息增益计算，算出一个增益，然后计算是否有工作的信息增益，找到最大的那个特征，为第一个结点，递归找到第二个（每找到一个特征在下次递归的时候就剔除），递归结束条件是，是否所有特征都被剔除了</li><li>缺点，容易过拟合，就像蝴蝶效应，如果在层数越低的时候出了问题，很容易造成后面的错误</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K-近邻算法</title>
    <link href="/2020/03/06/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/06/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="knn"><a class="markdownIt-Anchor" href="#knn"></a> KNN</h1><p>K-近邻算法，学名<strong>k nearest Neighbor(近的邻居)</strong>,简称**KNN，**该算法可以解决分类的问题</p><p><a href="https://www.bilibili.com/video/av37947862/?p=41" target="_blank" rel="noopener">推荐一个视频，讲的很详细</a></p><h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h2><ol><li><p>训练算法，需要先用一些已知样本进行训练</p></li><li><p>将未知分类的实例(样本)输入到算法中，并且设置k值，一般k设置成奇数</p></li><li><p>完成分类</p></li></ol><h2 id="举例分析"><a class="markdownIt-Anchor" href="#举例分析"></a> 举例分析</h2><ol><li>假如现在我们要将一部电影归类为是<strong>爱情电影 or 动作电影</strong>，我们用两个指标来判定<strong>一部电影中的打斗次数，一部电影中的接吻次数</strong></li><li>现在我们有一些已知类别的电影，和一些未知类别的电影，我们先将已知类别的电影放入到算法中进行训练，假如打斗次数是x，接吻次数是y，我们可以明显在坐标轴上看到打斗电影的点比较密集，爱情电影的点也比较密集，图上的点集分成两类</li><li>设置k值，并且将未排序的数据，投入到算法中，开始进行分类，先从第一个未分类点开始，计算所有已知样本点到该点的距离，找k个离该点最近的点，假如k=5，里面有3个点是爱情电影，2个点是动作电影，<strong>按照少数服从多数原则</strong>，该电影就会归类到爱情电影</li></ol><blockquote><ul><li>k一般取奇数是因为，假如k = 4，爱情电影和动作电影点分别有两个，那么这个电影就不好分类了</li><li>计算距离一般是算欧氏距离，即sqrt((x2-x1)^2 + (y2-y1)^2)，如果是三位的，依旧如此</li></ul></blockquote><h2 id="算法缺点"><a class="markdownIt-Anchor" href="#算法缺点"></a> 算法缺点</h2><ul><li>时间复杂度比较大，因为数据一多，比如未知样本有100，已知样本有100，则需要计算10000次，第一个样本需要计算他与100个样本的距离，要这样计算100次</li><li>分类不稳定，假如动作电影有100部，爱情电影有1000部，假如我们认为看一个未分类样本，应该是动作电影，但将他放入到算法中，设置k值为10时，由于动作电影稀疏，离他近的点有4个，但爱情电影多，很小范围就有6个点，那么这个点就会误认为时爱情电影</li></ul><h1 id="识别0~9数字系统实战"><a class="markdownIt-Anchor" href="#识别0~9数字系统实战"></a> 识别0~9数字系统(实战)</h1><blockquote><p>首先，<code>readlines</code>和<code>readline</code>都会读取到末尾的换行符，因此需要用<code>strip</code>来去掉</p></blockquote><pre class="highlight"><code class="">print(f.readlines())</code></pre><pre class="highlight"><code class="">['123\n', '1\n', '4']</code></pre><pre class="highlight"><code class="">print(f.readline().strip())</code></pre><h2 id="准备数据"><a class="markdownIt-Anchor" href="#准备数据"></a> 准备数据</h2><ul><li><p>现在我们有大量二进制数据<code>txt</code>文件，这些数据是通过搜集大量的手写0-9数字，然后通过光学识别，将图片转换成二进制32*32的矩阵保存在<code>txt</code>中，现在0数字有几百个数据，一共2000组<code>txt</code>文件</p></li><li><p>现在将32*32的数组转变成1*1024的<strong>行向量</strong>，32是2的5次方，刚好是1*2的10次方</p></li><li><p>故先设计矩阵转向量的函数，然后循环所有文件即可</p></li></ul><pre class="highlight"><code class="">def vector_transform(filename):    array = np.zeros((1, 1024))    with open(filename) as f:        for i in range(32):            each_line = f.readline().strip()            for j in range(32):                array[0, 32*i + j] = int(each_line[j])    return array</code></pre><blockquote><p><strong>注意<code>readline</code>读取文本都是<code>str</code>格式的数字，因此需要转成<code>int</code>类型</strong></p></blockquote><h2 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h2><pre class="highlight"><code class="">a = np.arange(10).reshape(2, 5)print(a)print(np.sum(a, axis=1))</code></pre><pre class="highlight"><code class="">[[0 1 2 3 4] [5 6 7 8 9]][10 35]</code></pre><ul><li><code>np.sum()</code>函数当<code>axis=1</code>时，会计算每一行的数据</li></ul><pre class="highlight"><code class="">a = np.array([[3, 1, 2],[4,5,6]])print(a)print(a.argsort(axis=0))print(a.argsort(axis=1))</code></pre><pre class="highlight"><code class="">[[3 1 2] [4 5 6]][[0 0 0] [1 1 1]][[1 2 0] [0 1 2]]</code></pre><ul><li><code>argsort()</code>,从小到大进行排序，返回坐标</li></ul><pre class="highlight"><code class="">import collectionsa = [1,1,2,3,4,1,2,3,2,2,2,2]print(collections.Counter(a))print(collections.Counter(a).most_common(1))print(collections.Counter(a).most_common(2))</code></pre><pre class="highlight"><code class="">Counter({2: 6, 1: 3, 3: 2, 4: 1})[(2, 6)][(2, 6), (1, 3)]</code></pre><ul><li><code>collections</code>模块，会统计所有出现元素出现的次数，用<code>most_common</code>打印出来</li></ul><h2 id="二维矩阵减一维向量"><a class="markdownIt-Anchor" href="#二维矩阵减一维向量"></a> 二维矩阵减一维向量</h2><pre class="highlight"><code class="">a = np.array([[1,1,1],[1,0,1],[1,0,0]])b = np.array([1,1,0])print(a - b)</code></pre><pre class="highlight"><code class="">[[ 0  0  1] [ 0 -1  1] [ 0 -1  0]]</code></pre><ul><li><code>ndarray</code>类型减法，每一行都会减这个行向量</li></ul><h2 id="完整代码和思路"><a class="markdownIt-Anchor" href="#完整代码和思路"></a> 完整代码和思路</h2><pre class="highlight"><code class="">import numpy as npfrom os import listdirfrom os.path import joinfrom collections import Counterpath = r'C:\Users\asus\Desktop\machinelearninginaction\Ch02\trainingDigits'test_path = r'C:\Users\asus\Desktop\machinelearninginaction\Ch02\testDigits'def vector_transform(filename):    array = np.zeros((1, 1024))    with open(filename) as f:        for i in range(32):            each_line = f.readline().strip()            for j in range(32):                array[0, 32*i + j] = int(each_line[j])    return arraydef training_data_set():    training_data = listdir(path)    file_number = len(training_data)    training_matrix = np.zeros((file_number, 1024))    training_label = []    i = 0    for each_file_name in training_data:        array = vector_transform(join(path, each_file_name))        training_label.append(int(each_file_name.split('_')[0]))        training_matrix[i, :] = array        i += 1    return training_matrix, training_label, file_numberdef classify(inx, dataset, label, k=5):    distance = (np.sum((dataset - inx)**2, axis=1))**0.5    label_index = [label[index] for index in distance.argsort()[0:k]]    result = Counter(label_index).most_common(1)[0][0]    return resultdef hw_test():    t = training_data_set()    test_file = listdir(test_path)    text_file_num = len(test_file)    error_count = 0    for each_file in test_file:        real_result = int(each_file.split('_')[0])        test_array = vector_transform(join(test_path, each_file))        test_array = np.tile(test_array, (t[2], 1))        result = classify(test_array, t[0], t[1], k=7)        if result != real_result:            error_count += 1    print(f'该算法的错误率是{error_count/text_file_num}')if __name__ == '__main__':    hw_test()</code></pre><p><strong>思路：</strong></p><ol><li>要先获得大量已知数据，和他对应的分类，由于数据格式是<code>32\*32</code>的<code>0-1</code>矩阵，所以可以转换成<code>1\*1024</code>的行向量，将所有文件矩阵都转换成行向量，然后合并成<code>（m,1024）</code>的矩阵</li><li>获得这些文件的分类标签，记得一一对应</li><li>使用<code>for</code>循环，遍历每个待测试文件，将待测试文件转换成行向量，计算该行向量与整个矩阵的距离</li><li>利用<code>argsort</code>获得距离最小的<code>k</code>个坐标，再利用<code>counter</code>算出<code>k</code>个中标签多的，得出分类结果</li></ol><ul><li>由于都是0-1矩阵，所以就不用将数据进行归一化了</li></ul><h1 id="knn数据分析实战"><a class="markdownIt-Anchor" href="#knn数据分析实战"></a> KNN数据分析实战</h1><h2 id="背景海伦约会"><a class="markdownIt-Anchor" href="#背景海伦约会"></a> 背景：海伦约会</h2><p>有一名女性，经常在网上与别人约会，对象会分成三类：</p><ol><li>不喜欢的人，<code>didntLike</code></li><li>魅力一般的人，<code>smallDoses</code></li><li>极具魅力的人，<code>largeDoses</code></li></ol><p>由于网上提供的数据有限，总是不能正常分类，所以海伦自己也搜集了一些数据，希望我们能将这些对象进行分类,部分数据如下：</p><pre class="highlight"><code class="">409208.3269760.953952largeDoses144887.1534691.673904smallDoses260521.4418710.805124didntLike7513613.1473940.428964didntLike383441.6697880.134296didntLike7299310.1417401.032955didntLike</code></pre><ul><li>数据的属性如下：<ul><li>每年的飞行里程</li><li>玩游戏所占时间比</li><li>每周消费的冰淇淋公升数</li></ul></li></ul><h3 id="数据分析"><a class="markdownIt-Anchor" href="#数据分析"></a> 数据分析</h3><ul><li>首先，我们要将数据转换成矩阵的形式</li></ul><blockquote><p>前三列数据都是数值型，而最后一列数据是字符串类型，我们知道类型分为三类，因此可以将他们转换成整数形式1，2，3</p></blockquote><ol><li>我们可以看到数据类型是<code>txt</code>格式的，而且是一行一行的数据，将数据放到程序目录下</li><li><code>readlines</code>函数可以将每一行数据读取并保存到列表中<code>'40920\t8.326976\t0.953952\tlargeDoses\n'</code></li><li>由于保存的是存在制表符和换行符的，所以我们需用字符串的<code>spilit</code>方法去掉末尾的换行符</li><li>去掉换行符后，我们可以用<code>spilit</code>方法，将每个元素切成四个部分保存在列表中</li><li>利用<code>numpy</code>创造一个新的同样类型的矩阵，1000行3列，并用切片方法赋值</li><li>利用if语句，将最后一列赋值为新的1，2，3</li></ol><pre class="highlight"><code class="">import numpy as npfilename = 'datingTestSet.txt'def file_matrix(filename):    with open(filename) as f:        arrayLines = f.readlines()    numerOflines = len(arrayLines)    return_mat = np.zeros((numerOflines, 3))    classLabelvector = []    index = 0    for each_line in arrayLines:        each_line = each_line.strip()        list_from_line = each_line.split('\t')        return_mat[index,:] = list_from_line[0:3]        if list_from_line[-1] == 'didntLike':            classLabelvector.append(1)        elif list_from_line[-1] == 'smallDoses':            classLabelvector.append(2)        elif list_from_line[-1] == 'largeDoses':            classLabelvector.append(3)        index += 1    return return_mat, classLabelvectorif __name__ == '__main__':    result = file_matrix(filename)</code></pre><pre class="highlight"><code class="">[[4.0920000e+04 8.3269760e+00 9.5395200e-01] [1.4488000e+04 7.1534690e+00 1.6739040e+00] [2.6052000e+04 1.4418710e+00 8.0512400e-01] ...</code></pre><h2 id="数据图的绘制"><a class="markdownIt-Anchor" href="#数据图的绘制"></a> 数据图的绘制</h2><pre class="highlight"><code class="">result = file_matrix(filename)x = result[0][:, 1]y = result[0][:, 2]plt.scatter(x, y,s=4)</code></pre><ul><li>result[0]是一个矩阵</li><li>size可以设置散点图的点的大小</li></ul><p>上面绘制的点颜色都是一样的，不好分辨点的分布，现在修改函数</p><pre class="highlight"><code class="">def color_label(classLabelvector):    colorLabel = []    for each in classLabelvector:        if each == 1:            colorLabel.append('red')        elif each == 2:            colorLabel.append('black')        elif each == 3:            colorLabel.append('green')    return colorLabelif __name__ == '__main__':    result = file_matrix(filename)    x = result[0][:, 1]    y = result[0][:, 2]    color = color_label(result[1])    plt.scatter(x, y, s=15, color=color)    plt.show()</code></pre><ul><li>scatter有个图标签，可以传一个数组进去</li></ul><p><img src="http://q6ip4it64.bkt.clouddn.com/Figure_1.png?e=1583930570&amp;token=IeqxMYJS9TcEnX8V6lUXD9FF_y3SCdOBApPAMpRy:3VwQnkM8PqMVP4oFi2cvRp7RRjk=&amp;attname=" srcset="/img/loading.gif" alt="" /></p><h2 id="计算样本点之间的距离"><a class="markdownIt-Anchor" href="#计算样本点之间的距离"></a> 计算样本点之间的距离</h2><pre class="highlight"><code class="">409208.3269760.953952largeDoses144887.1534691.673904smallDoses260521.4418710.805124didntLike7513613.1473940.428964didntLike</code></pre><p>这里有四个样本点，如果你要计算样本点3和样本点3的距离，由于维度是3，但是没有关系，我们依旧可以计算他的欧氏距离<br /><img src="http://q6ip4it64.bkt.clouddn.com/CodeCogsEqn.png?e=1583934436&amp;token=IeqxMYJS9TcEnX8V6lUXD9FF_y3SCdOBApPAMpRy:x_2ZGqMFPcRFSwG6sgKk2pj5Fqw=&amp;attname=" srcset="/img/loading.gif" alt="" /></p><ul><li>我们会发现，飞行的距离，对整个结果的影响实在是太大了，其他几个因素又和没有其实是一样的</li></ul><h2 id="数据的归一化"><a class="markdownIt-Anchor" href="#数据的归一化"></a> 数据的归一化</h2><p>为了避免上面的结果，我们往往会将数据进行归一化，将所有的数据取值处理到0-1或者-1-1</p><pre class="highlight"><code class="">a = np.random.random(10).reshape((2,5))print(a)print(a.min(0))</code></pre><pre class="highlight"><code class="">[[0.763841   0.33633528 0.45371754 0.34882551 0.17668197] [0.17092413 0.46925439 0.91786587 0.65634385 0.76016537]] [0.17092413 0.33633528 0.45371754 0.34882551 0.17668197]</code></pre><ul><li>可以发现<code>a.min(0)</code>这样将每一列中的最小数据都挑出来了，并且生成了一个数组</li></ul><pre class="highlight"><code class="">def dataNorm(result):# 获得每一列的最大最小值    min_values = result.min(0)    max_values = result.max(0)    ranges = max_values - min_values    # 获得行数    row = result.shape[0]    # 对应元素进行四则运算    new_Norm_data = (result - np.tile(min_values, (row, 1)))/np.tile(ranges, (row, 1))    return new_Norm_data</code></pre><ul><li>现在<code>ndarray</code>形式的数组好处就体现出来了，加减乘除都可以对应元素加减乘除，而不会依据矩阵的运算来进行</li><li><code>numpy.tile()</code>的用法</li></ul><pre class="highlight"><code class="">a = [1,2,3,4]print(np.tile(a, (1, 2)))print(np.tile(a, (3, 1)))</code></pre><pre class="highlight"><code class="">[[1 2 3 4 1 2 3 4]][[1 2 3 4] [1 2 3 4] [1 2 3 4]]</code></pre><blockquote><p>可以发现，必须传入一个列表，当右边传入一个元组时，<code>left</code>表示复制的行数，<code>right</code>表示复制的列数，复制后生成一个<code>ndarray</code>形式的数组</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2020/03/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg" target="_blank" rel="noopener">排序算法的动画在这里</a>，概念讲的很透彻</p><p>由于上面的排序代码是java写的，所以这里我会用python来实现一遍</p><h2 id="什么是内部排序什么是外部排序"><a class="markdownIt-Anchor" href="#什么是内部排序什么是外部排序"></a> 什么是内部排序，什么是外部排序</h2><ul><li>内部排序指的是在内存 里面进行的排序</li><li>外部排序是当数据很大，内存存放不了的时候，需要用到外存进行数据排序</li></ul><h2 id="什么是排序算法的稳定性"><a class="markdownIt-Anchor" href="#什么是排序算法的稳定性"></a> 什么是排序算法的稳定性</h2><p>通俗地说就是假如数据中有很多同样大小的数据，在排序中，如果这些数据的<strong>相对次序</strong>不会发生变化，则称这个排序算法是稳定的</p><blockquote><p><strong>相对次序</strong>是指排序前，你在我左边，排序后，你依旧在我左边</p></blockquote><h2 id="1-冒泡排序"><a class="markdownIt-Anchor" href="#1-冒泡排序"></a> 1. 冒泡排序</h2><h3 id="算法步骤假设从小到大排序"><a class="markdownIt-Anchor" href="#算法步骤假设从小到大排序"></a> 算法步骤（假设从小到大排序）</h3><ol><li>比较第一个和第二个数，如果第一个大于第二个，则交换两个数据位置</li><li>再比较第二个和第三个，重复交换步骤，执行一轮后，最右边应该存放着最大的数</li><li>进行一轮后，重复1，2步骤，但是不用比较最后一个数字</li><li>重复多轮，完成冒泡排序</li></ol><h3 id="python代码实现"><a class="markdownIt-Anchor" href="#python代码实现"></a> python代码实现</h3><pre class="highlight"><code class="">list1 = [5, 4, 3, 2, 1]def rank(list1):    # 2个数据只要排一轮，3个数据只要排两轮,这里需要四轮    for i in range(1, len(list1)):        for j in range(len(list1) - i):            if list1[j] &gt; list1[j + 1]:                temp = list1[j]                list1[j] = list1[j + 1]                list1[j + 1] = temp    return list1print(rank(list1))</code></pre><h3 id="代码改进"><a class="markdownIt-Anchor" href="#代码改进"></a> 代码改进</h3><pre class="highlight"><code class="">list1 = [5, 4, 3, 2, 1]def rank(list1):    for i in range(1, len(list1)):        for j in range(len(list1) - i):            if list1[j] &gt; list1[j + 1]:                list1[j], list1[j + 1] = list1[j + 1], list1[j]    return list1print(rank(list1))</code></pre><h2 id="2-选择排序"><a class="markdownIt-Anchor" href="#2-选择排序"></a> 2. 选择排序</h2><h3 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h3><ol><li>首先在未排序的数组中，找到最小的那一个，和第一个交换位置</li><li>在剩下的数组中，找到最小的，排在第二位</li><li>排序好的，可以不用再查找最小的那个数了</li><li>重复，知道排序完成</li></ol><h3 id="python实现算法"><a class="markdownIt-Anchor" href="#python实现算法"></a> python实现算法</h3><pre class="highlight"><code class="">list1 = [5, 4, 3, 2, 1]def rank(list1):    temp = 0    for each in range(len(list1) - 1):        for i in range(len(list1) - 1):            if list1[i] &gt; list1[i + 1]:                #找到最小的那个，将他的下标存储在temp中，这里的temp是局部变量，所以在最开始让他赋值为0                temp = i + 1        new = list1[each]        list1[each] = list1[temp]        list1[temp] = new    return list1print(rank(list1))</code></pre><h3 id="代码改进-2"><a class="markdownIt-Anchor" href="#代码改进-2"></a> 代码改进</h3><blockquote><p>在上面的代码中，根本就不需要使用到交换顺序这个方法，此外，排序好的就不用再检查了,</p></blockquote><pre class="highlight"><code class="">`list1[each], list1[temp] = list1[temp], list1[each]`相当于new = list1[each]list1[each] = list1[temp]list1[temp] = new</code></pre><pre class="highlight"><code class="">list1 = [5, 4, 7, 3, 2, 1]def rank(list1):    temp = 0    for each in range(len(list1) - 1):        for i in range(each, len(list1) - 1):            if list1[i] &gt; list1[i + 1]:                #找到最小的那个，将他的下标存储在temp中，这里的temp是局部变量，所以在最开始让他赋值为0                temp = i + 1        list1[each], list1[temp] = list1[temp], list1[each]        #等号号右边和左边不影响,只要保证temp=each，each=temp即可    return list1print(rank(list1))</code></pre><h2 id="插入排序法"><a class="markdownIt-Anchor" href="#插入排序法"></a> 插入排序法</h2><h3 id="算法步骤-2"><a class="markdownIt-Anchor" href="#算法步骤-2"></a> 算法步骤</h3><ol><li>现给出一个数组，将第0个看成是有序的，剩下的看成是未排序的</li><li>扫描未排序的第一个，将他插入到已排序中的合适的位置(和他之前那个比较，如果大小不对，则交换两者位置，每交换一次，temp不断向前移动一次，知道位置正确)</li><li>继续扫描未排序的第一个，重复步骤2，直到排序完成</li></ol><h3 id="python代码"><a class="markdownIt-Anchor" href="#python代码"></a> python代码</h3><pre class="highlight"><code class="">list1 = [3, 1, 3, 22, 23, 1]for i in range(1, len(list1)):    temp = i    for j in range(0, i):        if list1[temp] &lt; list1[i - 1 - j]:        #这里需要temp存储交换后的位置，每交换一次减1，且每次只和之前的1个比较            list1[temp - 1], list1[temp] = list1[temp], list1[temp - 1]            temp -= 1print(list1)</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与时间复杂度</title>
    <link href="/2020/03/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2020/03/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是数据结构"><a class="markdownIt-Anchor" href="#什么是数据结构"></a> 什么是数据结构</h2><p>数据结构，顾名思义，就是数据的存储方式</p><ul><li><p>常见的有数组，可以想象成一个个抽屉，数组就是这样，每个数据紧靠在一起，并且分配有一定的空间</p></li><li><p>链表，就像数组一样，但是每个抽屉还存放着指向下一个抽屉的地址</p></li></ul><h2 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h2><p>由于一个问题对应多个算法，要区分算法的好坏就需要讨论算法的时间复杂度和空间复杂度</p><blockquote><ul><li>在计算机程序中，通常我们可以用end - star 来计算程序运行的时间，但是由于程序一般运行时间很短，两个算法运行的时间可能看不出差别，所以这里可以使用for循环几万次来观察时间长短</li></ul></blockquote><p>时间复杂度O表示法</p><blockquote><ul><li>定义为随着处理数据的变化，程序运行的时间是如何变化的，这里类似于极限的思想，我们知道在数据趋于无穷大的时候，要抓大头，例如一个数据时间复杂度满足t = n<sup>2/2+n，我们可以先将n约掉，只看n</sup>2/2，进一步，我们可表示成O(n^2)，通常很坐标表示数据量n，纵坐标表示所消耗的时间t</li><li>O(1)表示时间复杂度是常数，比如数组，我们只要计算偏移量，也就是第0个加一下就行，就算数据再大，依旧只是加一下而已</li><li>O(n)比如链表，要查找链表中的数据，我们需要从第一个往后面查找，假如每找一个需要花费1秒，那么只要数据量一旦加大，时间呈t = n增长，所以时间复杂度为O(n)</li><li>一层for循环的时间复杂度是O(n)，两层就是O(m^n)，因为每个都要循环m次，n个m相乘</li><li>常见的算法时间复杂度由小到大依次为：****Ο(1)＜Ο(log*2n*)＜Ο(n)＜Ο(nlog*2n*)＜Ο(*n*2)＜Ο(*n*3)＜…＜Ο(*2*n)＜Ο(n!)****</li></ul></blockquote><p>如何表示时间复杂度</p><ul><li>找出算法中的基本语句；</li></ul><p>算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。</p><ul><li>计算基本语句的执行次数的数量级；</li></ul><p>只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。</p><ul><li>用大Ο记号表示算法的时间性能。</li></ul><p>将基本语句执行次数的数量级放入大Ο记号中。</p><p>如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：</p><pre class="highlight"><code class="java">　　<span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=n; i++)　　       x++;　　<span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=n; i++)　     　<span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>; j&lt;=n; j++)　　          x++;</code></pre><p>第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(<em>n</em>2)，则整个算法的时间复杂度为<strong>Ο(n+<em>n</em>2)=Ο(<em>n</em>2)</strong>。</p><p>Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中<strong>Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n<sup>2)和Ο(n</sup>3)<strong>称为多项式时间，<strong>而Ο(2^n)和Ο(n!)称为指数时间</strong>。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为</strong>P（Polynomial,多项式）类问题</strong>，而把后者（即指数时间复杂度的算法）称为（ 非确定多项式）问题。</p><h2 id="算法时间复杂度分析法则"><a class="markdownIt-Anchor" href="#算法时间复杂度分析法则"></a> 算法时间复杂度分析法则</h2><blockquote><ul><li><p>对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间</p></li><li><p>对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下&quot;求和法则&quot;</p></li><li><p><strong>求和法则</strong>:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n)))  特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))</p></li><li><p>对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间</p></li><li><p>对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下&quot;乘法法则&quot;</p></li><li><p><strong>乘法法则</strong>: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1*T2=O(f(n)*g(n))</p></li></ul></blockquote><ul><li><strong>O(1)</strong></li></ul><blockquote><p>Temp=i; i=j; j=temp;</p><p>以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。**注意：如果算法的执行时间不随着问题规模*<em>n*<em>的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是*<em>O(1)*</em>。</em></em></p></blockquote><ul><li><strong>O(n^2)</strong></li></ul><blockquote><p>交换i和j的内容</p><pre class="highlight"><code class="java"></code></pre></blockquote><pre><code> sum=0；                 （一次） for(i=1;i&lt;=n;i++)     （n+1次）    for(j=1;j&lt;=n;j++) （n2次）     sum++；            （n2次） ``` 解：因为Θ(2\*n^2+n+1)=n^2（即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(n^2)；</code></pre><ul><li><p>**O(log n)**表示以2为底的log</p><p>i=1;     ①<br />while (i&lt;=n)<br />i=i*2; ②</p></li></ul><blockquote><p>语句1的频度是1,<br />设语句2的频度是f(n),  则：2^f(n)&lt;=n;f(n)&lt;=<strong>log*2n*</strong><br />取最大值f(n)=<strong>log*2n*</strong>,<br />T(n)=O(<strong>log*2n*</strong> )</p></blockquote><p><img src="https://img-blog.csdn.net/20130920172327687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvem9sYWxhZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img" /></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习数学基础</title>
    <link href="/2020/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>首先这里推荐一个<a href="https://zhuanlan.zhihu.com/p/25197792" target="_blank" rel="noopener">数学基础教程</a>，里面介绍了大部分的机器学习需要用到的数学知识</p><p>推荐下知乎上作者<a href="https://www.zhihu.com/lives/926880054670159872" target="_blank" rel="noopener">跨行业转机器学习的live</a></p><p>下面我将筛选一些比较重要的知识</p><h2 id="向量"><a class="markdownIt-Anchor" href="#向量"></a> 向量</h2><p>一个向量就是一列数，这些数是有序排列的。我们可以把向量看作空间中的点，每个元素是不同的坐标轴上的坐标。</p><h2 id="张量"><a class="markdownIt-Anchor" href="#张量"></a> 张量</h2><p>张量其实就像在x，y轴上突然引进一个z轴一样，通俗一点理解的话，我们可以将标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶张量。当然我们还可以将这一定义继续扩展，即：我们可以用四阶张量表示一个包含多张图片的数据集，这四个维度分别是：图片在数据集中的编号，图片高度、宽度，以及色彩数据。</p><h2 id="范数"><a class="markdownIt-Anchor" href="#范数"></a> 范数</h2><p>**有时我们需要衡量一个向量的大小。**在机器学习中，我们经常使用被称为范数(norm) 的函数衡量矩阵大小。</p><ul><li><p>L1范数<img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+%5Cleft%7C+x+%5Cright%7C+%5Cright%7C+" srcset="/img/loading.gif" alt="[公式]" />：为x向量各个元素绝对值之和；</p></li><li><p>L2范数<img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+%5Cleft%7C+x+%5Cright%7C+%5Cright%7C+_%7B2%7D+" srcset="/img/loading.gif" alt="[公式]" />：为x向量各个元素平方和的开方。</p><p><strong>百度百科了一下，发现看不懂，这个挺重要的，先记住再说</strong></p></li></ul><h2 id="奇异值分解singular-value-decompositionsvd"><a class="markdownIt-Anchor" href="#奇异值分解singular-value-decompositionsvd"></a> <strong>奇异值分解（Singular Value Decomposition，SVD）</strong></h2><p>矩阵的特征分解是有前提条件的，那就是只有对可对角化的矩阵才可以进行特征分解。但实际中很多矩阵往往不满足这一条件，甚至很多矩阵都不是方阵，就是说连矩阵行和列的数目都不相等。这时候怎么办呢？人们将矩阵的特征分解进行推广，得到了一种叫作“矩阵的奇异值分解”的方法，简称SVD。通过奇异分解，我们会得到一些类似于特征分解的信息。</p><h2 id="贝叶斯公式"><a class="markdownIt-Anchor" href="#贝叶斯公式"></a> 贝叶斯公式</h2><p>贝叶斯公式贯穿了机器学习中随机问题分析的全过程。从文本分类到概率图模型，其基本分类都是贝叶斯公式。</p><h3 id="全概率公式"><a class="markdownIt-Anchor" href="#全概率公式"></a> 全概率公式</h3><p><a href="%5Bhttps://baike.baidu.com/item/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F%5D(https://baike.baidu.com/item/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F)">百度百科</a></p><p>全概率公式为<a href="https://baike.baidu.com/item/%E6%A6%82%E7%8E%87%E8%AE%BA/829122" target="_blank" rel="noopener">概率论</a>中的重要公式，它将对一复杂事件A的概率求解问题转化为了在不同情况下发生的简单事件的概率的求和问题。</p><p>内容：如果事件B1、B2、B3…Bn 构成一个完备事件组，即它们两两互不相容，其和为全集；并且P（Bi)大于0，则对任一事件A有</p><p>P(A)=P(A|B1)P(B1) + P(A|B2)P(B2) + … + P(A|Bn)P(Bn)。</p><p>或者：p(A)=P(AB1)+P(AB2)+…+P(ABn))，其中A与Bn的关系为交)。</p><h3 id="先验概率"><a class="markdownIt-Anchor" href="#先验概率"></a> 先验概率</h3><p><a href="%5Bhttps://baike.baidu.com/item/%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87%5D(https://baike.baidu.com/item/%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87)">百度百科</a></p><p>先验概率（prior probability）是指根据以往经验和分析得到的概率，如全概率公式，它往往作为&quot;由因求果&quot;问题中的&quot;因&quot;出现的概率。</p><h3 id="后验概率"><a class="markdownIt-Anchor" href="#后验概率"></a> 后验概率</h3><p><a href="%5Bhttps://baike.baidu.com/item/%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87%5D(https://baike.baidu.com/item/%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87)">百度百科</a></p><p>事情还没有发生，要求这件事情发生的可能性的大小，是<strong>先验概率</strong>。事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，是<strong>后验概率</strong>。</p><p>假设某种病在人群中的发病率是0.001，即1000人中大概会有1个人得病，则有： <strong>P(患病) = 0.1%</strong>；即：在没有做检验之前，我们预计的患病率为<strong>P(患病)=0.1%</strong>，这个就叫作**“先验概率”**。</p><p>现在我们想知道的是：在做完检测显示为阳性后，某人的患病率<strong>P(患病|显示阳性)</strong>，这个其实就称为**“后验概率”。**</p><p>这里先了解<strong>条件概率公式</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+B%7CA+%5Cright%29%3D%5Cfrac%7BP%5Cleft%28+AB+%5Cright%29%7D%7BP%5Cleft%28+A+%5Cright%29%7D+%2C+P%5Cleft%28+A%7CB+%5Cright%29%3D%5Cfrac%7BP%5Cleft%28+AB+%5Cright%29%7D%7BP%5Cleft%28+B+%5Cright%29%7D" srcset="/img/loading.gif" alt="[公式]" /></p><p>由条件概率可以得到<strong>乘法公式</strong>：</p><p>乘法公式就是<strong>P(AB)</strong></p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+AB+%5Cright%29%3DP%5Cleft%28+B%7CA+%5Cright%29P%5Cleft%28+A+%5Cright%29%3DP%5Cleft%28+A%7CB+%5Cright%29P%5Cleft%28+B+%5Cright%29" srcset="/img/loading.gif" alt="[公式]" /></p><p>将条件概率公式和乘法公式结合可以得到：</p><p><strong>这里说明由先验公式可以算出后验公式</strong></p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+B%7CA+%5Cright%29%3D%5Cfrac%7BP%5Cleft%28+A%7CB+%5Cright%29%5Ccdot+P%5Cleft%28+B+%5Cright%29%7D%7BP%5Cleft%28+A+%5Cright%29%7D" srcset="/img/loading.gif" alt="[公式]" /></p><p>再由<strong>全概率公式</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+A+%5Cright%29%3D%5Csum_%7Bi%3D1%7D%5E%7BN%7D%7BP%5Cleft%28+A%7CB_%7Bi%7D+%5Cright%29+%5Ccdot+P%5Cleft%28+B_%7Bi%7D%5Cright%29%7D+" srcset="/img/loading.gif" alt="[公式]" /></p><p>代入可以得到<strong>贝叶斯公式</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+B_%7Bi%7D%7CA+%5Cright%29%3D%5Cfrac%7BP%5Cleft%28+A%7CB_%7Bi%7D+%5Cright%29%5Ccdot+P%5Cleft%28+B_%7Bi%7D+%5Cright%29%7D%7B%5Csum_%7Bi%3D1%7D%5E%7BN%7D%7BP%5Cleft%28+A%7CB_%7Bi%7D+%5Cright%29+%5Ccdot+P%5Cleft%28+B_%7Bi%7D%5Cright%29%7D+%7D" srcset="/img/loading.gif" alt="[公式]" /></p><h2 id="方差"><a class="markdownIt-Anchor" href="#方差"></a> 方差</h2><p>概率中，方差用来衡量随机变量与其数学期望之间的偏离程度；统计中的方差为样本方差，<strong>是各个样本数据分别与其平均数之差的平方和的平均数</strong>。数学表达式如下：</p><p><img src="https://www.zhihu.com/equation?tex=Var%5Cleft%28+x+%5Cright%29+%3DE%5Cleft%5C%7B+%5Cleft%5B+x-E%5Cleft%28+x+%5Cright%29+%5Cright%5D+%5E%7B2%7D+%5Cright%5C%7D+%3DE%5Cleft%28+x%5E%7B2%7D+%5Cright%29+-%5Cleft%5B+E%5Cleft%28+x+%5Cright%29+%5Cright%5D+%5E%7B2%7D+" srcset="/img/loading.gif" alt="[公式]" /></p><h2 id="期望"><a class="markdownIt-Anchor" href="#期望"></a> 期望</h2><p>在概率论和统计学中，数学期望是试验中每次可能结果的概率乘以其结果的总和。它是最基本的数学特征之一，反映随机变量平均值的大小。</p><p>假设X是一个离散随机变量，其可能的取值有：<img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B+x_%7B1%7D+%2Cx_%7B2%7D+%2C......%2Cx_%7Bn%7D+%5Cright%5C%7D+" srcset="/img/loading.gif" alt="[公式]" />，各个取值对应的概率取值为：<img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+x_%7Bk%7D+%5Cright%29+%2C+k%3D1%2C2%2C......%2Cn" srcset="/img/loading.gif" alt="[公式]" />，则其数学期望被定义为：</p><p><img src="https://www.zhihu.com/equation?tex=E%5Cleft%28X+%5Cright%29+%3D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%7Bx_%7Bk%7D+P%5Cleft%28+x_%7Bk%7D+%5Cright%29+%7D+" srcset="/img/loading.gif" alt="[公式]" /></p><p>假设X是一个连续型随机变量，其概率密度函数为<img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+x+%5Cright%29+" srcset="/img/loading.gif" alt="[公式]" />则其数学期望被定义为：</p><p><strong>也就是求和换成积分了</strong></p><p><img src="https://www.zhihu.com/equation?tex=E%5Cleft%28+x+%5Cright%29+%3D%5Cint_%7B-%5Cvarpi+%7D%5E%7B%2B%5Cvarpi+%7D+xf%5Cleft%28+x+%5Cright%29+dx" srcset="/img/loading.gif" alt="[公式]" /></p><h2 id="协方差"><a class="markdownIt-Anchor" href="#协方差"></a> 协方差</h2><h5 id="协方差其意义看这超详细"><a class="markdownIt-Anchor" href="#协方差其意义看这超详细"></a> <strong>协方差</strong>其意义：<a href="https://blog.csdn.net/GoodShot/article/details/79940438" target="_blank" rel="noopener">看这,超详细</a></h5><p><strong>度量各个维度偏离其均值的程度。协方差的值如果为正值，则说明两者是正相关的(从协方差可以引出“相关系数”的定义)，结果为负值就说明负相关的，如果为0，也是就是统计上说的“相互独立”。</strong></p><p>在概率论和统计学中，协方差被用于衡量两个随机变量X和Y之间的总体误差。数学定义式为：</p><p><img src="https://www.zhihu.com/equation?tex=Cov%5Cleft%28+X%2CY+%5Cright%29+%3DE%5Cleft%5B+%5Cleft%28+X-E%5Cleft%5B+X+%5Cright%5D+%5Cright%29+%5Cleft%28+Y-E%5Cleft%5B+Y+%5Cright%5D+%5Cright%29+%5Cright%5D+%3DE%5Cleft%5B+XY+%5Cright%5D+-E%5Cleft%5B+X+%5Cright%5D+E%5Cleft%5B+Y+%5Cright%5D+" srcset="/img/loading.gif" alt="[公式]" /></p><h2 id="泊松分布指数分布"><a class="markdownIt-Anchor" href="#泊松分布指数分布"></a> 泊松分布&amp;&amp;指数分布</h2><p><a href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html" target="_blank" rel="noopener">阮一峰的博客，讲的很详细</a></p><ul><li>泊松分布<ul><li>日常生活中，大量事件是有固定频率的。</li></ul></li></ul><p>某医院平均每小时出生3个婴儿<br />某公司平均每10分钟接到1个电话<br />某超市平均每天销售4包xx牌奶粉<br />某网站平均每分钟有2次访问<br />它们的特点就是，我们可以预估这些事件的总数，但是没法知道具体的发生时间。已知平均每小时出生3个婴儿，请问下一个小时，会出生几个？</p><p><strong>泊松分布就是描述某段时间内，事件具体的发生概率。</strong></p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+N%5Cleft%28+t+%5Cright%29+%3Dn+%5Cright%29+%3D%5Cfrac%7B%5Cleft%28+%5Clambda+t+%5Cright%29+%5E%7Bn%7De%5E%7B-%5Clambda+t%7D+%7D%7Bn%21%7D+" srcset="/img/loading.gif" alt="[公式]" /></p><p>其中：</p><p>P表示概率，N表示某种函数关系，t表示时间，n表示数量，1小时内出生3个婴儿的概率，就表示为 P(N(1) = 3) ；λ 表示事件的频率。</p><p>还是以上面医院平均每小时出生3个婴儿为例，则<img src="https://www.zhihu.com/equation?tex=%5Clambda+%3D3" srcset="/img/loading.gif" alt="[公式]" />；</p><p>那么，接下来两个小时，一个婴儿都不出生的概率可以求得为：</p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+N%5Cleft%282+%5Cright%29+%3D0+%5Cright%29+%3D%5Cfrac%7B%5Cleft%28+3%5Ccdot+2+%5Cright%29+%5E%7Bo%7D+%5Ccdot+e%5E%7B-3%5Ccdot+2%7D+%7D%7B0%21%7D+%5Capprox+0.0025" srcset="/img/loading.gif" alt="[公式]" /></p><p>同理，我们可以求接下来一个小时，至少出生两个婴儿的概率：</p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+N%5Cleft%28+1+%5Cright%29+%5Cgeq+2+%5Cright%29+%3D1-P%5Cleft%28+N%5Cleft%28+1+%5Cright%29%3D0+%5Cright%29+-+P%5Cleft%28+N%5Cleft%28+1+%5Cright%29%3D1+%5Cright%29%5Capprox+0.8" srcset="/img/loading.gif" alt="[公式]" /></p><p>**指数分布是事件的时间间隔的概率。**下面这些都属于指数分布。</p><blockquote><ul><li>婴儿出生的时间间隔</li><li>来电的时间间隔</li><li>奶粉销售的时间间隔</li><li>网站访问的时间间隔</li></ul></blockquote><p>指数分布的公式可以从泊松分布推断出来。如果下一个婴儿要间隔时间 t ，就等同于 t 之内没有任何婴儿出生。</p><ul><li>接下来15分钟，会有婴儿出生的概率是52.76%。</li><li>接下来的15分钟到30分钟，会有婴儿出生的概率是24.92%。</li></ul><p>未完待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希图 and 移动窗口</title>
    <link href="/2020/03/03/leetcode%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <url>/2020/03/03/leetcode%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目1-两数之和"><a class="markdownIt-Anchor" href="#题目1-两数之和"></a> 题目1 两数之和</h2><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><pre class="highlight"><code class="">给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3><pre class="highlight"><code class="python">list1 = [<span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>]target = <span class="hljs-number">9</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list1:        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> list1[list1.index(i) + <span class="hljs-number">1</span>:]:            <span class="hljs-keyword">if</span> i + j == target:                <span class="hljs-keyword">return</span> print([list1.index(i), list1.index(j)])find()</code></pre><h3 id="算法-哈希字典查找"><a class="markdownIt-Anchor" href="#算法-哈希字典查找"></a> 算法 哈希字典查找</h3><blockquote><p><strong>什么是哈希图呢，python中的字典就是用的哈希图来查找，假设我们现在有5个抽屉，序号为0，1，2，3，4，现在一个对象key，经过哈希算法，会生成一个固定长度的数字，这个数字mod5，求出假如余数是1，那么这个数据value对应的就会存放在1这个抽屉中，假如这时候又一个数据余数是1，这个数据也会存放在1中，所以python中的字典不允许有两个一样的key，否则会更新这里面存储的数据</strong></p></blockquote><ol><li>暴力搜索法</li></ol><blockquote><p>我的思路就是暴力搜索法，利用两层循环结构，只要找到答案，就马上return结束</p></blockquote><ol start="2"><li>哈希字典查找</li></ol><pre class="highlight"><code class="">list1 = [4, 11, 11, 15, 0, 4, 0, 3, 7]target = 8def find():    hash = {}    for key, value in enumerate(list1):        if target - value in hash:            return [hash[target - value], key]        hash[value] = key   #这句不能放在if前面,防止target-num = num,这样就不会包括自身print(find())</code></pre><p>这里涉及到的知识：</p><ol><li><p>enumerate函数</p><pre class="highlight"><code class="">enumerate([1,2])Out[3]: &lt;enumerate at 0x16b8c273cc8&gt;list(enumerate([1, 2]))Out[4]: [(0, 1), (1, 2)]for i, n in enumerate([1,2,3]):  ...:    print(i, n)  ...:    0 11 22 3</code></pre></li><li><p>本题目是要寻找两数之和，并且返回下标，而字典是哈希，这样可以直接找到，即如果<code>target - num</code>在字典中，说明找到了，然后就可以直接返回</p></li><li><p>首先我们创建一个空的字典，然后for循环遍历，每循环一次，就往字典中加入这个数字，例如target = 9，现在有个2，则只要判断7在不在字典中即可，因为第一次为空，肯定不在的，循环一次后字典还有2，接下来假如轮到7，9-7=2，判断2是不是在字典中，发现之前字典存了2，所以直接输出就行了</p></li><li><p>注意这里<code>hash[value] = key</code> #这句不能放在if前面,防止<code>target-num = num</code>,这样就不会包括自身</p></li><li><p><code>if target - value in hash:</code>这里只能判断键在不在里面，<code>hash[value] = key</code>所以我这里换了个位置相当于2是0号位置{2：0}</p></li></ol><h3 id="知识补充python字典与哈希的关系"><a class="markdownIt-Anchor" href="#知识补充python字典与哈希的关系"></a> 知识补充，python字典与哈希的关系</h3><p>Python 调用内部的散列函数，将键（Key）作为参数进行转换，得到一个唯一的地址（这也就解释了为什么给相同的键赋值会直接覆盖的原因，因为相同的键转换后的地址是一样滴），然后将值（Value）存放到该地址中。</p><p>对于 Python 来说，键（Key）必须是可哈希的，换句话说就是要可以通过散列函数计算出唯一地址的。那如果拿一个变量当键（Key）可以吗？肯定不行。因为变量随时都可能改变，不符合可哈希原则！</p><p>同样的，列表、字典、集合这些都是可变的，所以都不能做为键（Key）来使用。</p><p>那有朋友可能会问，那元祖呢？元祖总该是不变的吧？</p><p>其实不然，因为元祖里边可以存放列表这类可变因素，所以如果实在想拿元祖当字典的键（Key），那必须对元祖做限制：元组中只包括像数字和字符串这样的不可变元素时，才可以作为字典中有效的键（Key）。</p><p>另外还需要注意的一点是，Python 的哈希算法对相同的值计算得到的结果是一样的，也就是说 12315 和 12315.0 的值相同，他们被认为是相同的键（Key）。</p><h2 id="题目三-无重复字符的最长字符串"><a class="markdownIt-Anchor" href="#题目三-无重复字符的最长字符串"></a> 题目三 无重复字符的最长字符串</h2><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><pre class="highlight"><code class="给定一个字符串，请你找出其中不含有重复字符的">示例 1:输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。示例 2:输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。示例 3:输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h3 id="算法-移动窗口"><a class="markdownIt-Anchor" href="#算法-移动窗口"></a> 算法 移动窗口</h3><pre class="highlight"><code class="">s = 'abcabacda'str1 = ''list1 = []for each_str in s:    if each_str not in str1:        str1 += each_str        list1.append(len(str1))    else:        str1 = str1[str1.index(each_str) + 1:] + each_strprint(max(list1))</code></pre><pre class="highlight"><code class="a">ababcbacbacd4</code></pre><h3 id="错误解法"><a class="markdownIt-Anchor" href="#错误解法"></a> 错误解法</h3><pre class="highlight"><code class="">s = 'abcabacda'str1 = ''list1 = []for each_str in s:    if each_str not in str1:        str1 += each_str        list1.append(len(str1))        print(str1)    else:        str1 = str1[1:] + each_strprint(max(list1))aababcabacabacd5</code></pre><p>什么是移动窗口？给你一串数据，可以是列表或者字符串，设置一个小窗口，从左到右不断移动，也就是左边出，右边进，这题规定不能有重复的出现，所以<code>str1 = str1[1:] + each_str</code>这样不断左移一个是不行的<code>abac</code>必须在重复的位置，前面出现a的左边全部切掉，切掉后数据长度必定减短</p><p>这里附上最好的解法，运算时间和占用内存都是最低的</p><pre class="highlight"><code class="">s = 'abcabacd'length, j = 0, -1for i, x in enumerate(s):    if x in s[j + 1:i]:        length = max(length, i - j - 1)        j = s[j + 1:i].index(x) + j + 1print(max(length, len(s) - 1 - j))</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1 零基础学机器学习</title>
    <link href="/2020/03/01/1-0%E5%9F%BA%E7%A1%80%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/03/01/1-0%E5%9F%BA%E7%A1%80%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="机器学习使用场景"><a class="markdownIt-Anchor" href="#机器学习使用场景"></a> 机器学习使用场景</h2><p>机器学习已经有了十分广泛的应用，例如：数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人运用。</p><h2 id="模式识别机器学习深度学习"><a class="markdownIt-Anchor" href="#模式识别机器学习深度学习"></a> 模式识别&amp;机器学习&amp;深度学习</h2><ul><li>模式识别，模式识别就是让计算机也具备有识别东西的能力，比如让计算机识别手写数字数8，这叫做手写识别技术，也是模式识别的一个应用场景，其他的还有语音识别，声纹识别(可以知道你是哪个人)，人脸识别，指纹识别等</li></ul><blockquote><p>我们应该先对计算机进行数据的训练，比如搜集很多手写的8（训练），将他们变成矩阵存储到计算机中，这样计算机就认识8了，当计算机遇到一个新的8时，就会对之前的数据进行匹配，当匹配很近似时，计算机就会认为这就是8</p></blockquote><ul><li><p>机器学习，首先，你要搜集很多的数据，以及为程序选择一个算法，然后将数据导入到计算机中，等上一段时间，让计算机自己去学习这些数据</p><blockquote><p>模式识别需要我们去给计算机喂饭，而机器学习就是我们把饭煮好了，让他自己吃</p></blockquote></li><li><p>深度学习，深度学习是机器学习的一个子类，是模仿人类大脑思考而创造的一个方法，利用的是神经网络，往往需要大量的数据，来模拟人脑进行数据的解释<br /><a href="https://www.zhihu.com/question/57770020" target="_blank" rel="noopener">机器学习还有很多的缺点</a></p><blockquote><p>机器学习包含深度学习，机器学习适合各种数据量的训练，因此训练时间有长有短，而神经网络的训练需要大量的数据，而且花费的时间比较长</p></blockquote></li></ul><h2 id="大数据人工智能"><a class="markdownIt-Anchor" href="#大数据人工智能"></a> 大数据&amp;人工智能</h2><ul><li>大数据，就是对大量的数据进行存储和分析，由分析结果来进行决策，现在大数据经常和机器学习相结合</li><li>人工只能范围很大，如果有人说自己是做人工智能的，你可以问他是做什么方向的，或者他什么都不知道</li></ul><h2 id="机器学习的组成"><a class="markdownIt-Anchor" href="#机器学习的组成"></a> 机器学习的组成</h2><h3 id="分类回归"><a class="markdownIt-Anchor" href="#分类回归"></a> 分类&amp;回归</h3><ul><li>分类：将数据划分到合适的类别中，例如手写一个新的数据8，计算机会识别，将他归类到8中</li><li>回归：用于数据的预测，先对已有的数据进行分析，得到一个函数</li></ul><h3 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h3><h4 id="监督学习"><a class="markdownIt-Anchor" href="#监督学习"></a> 监督学习</h4><p><strong>监督学习</strong>，就是人们常说的分类，通过已有的训练样本（即已知数据以及其对应的输出）去训练得到一个最优模型（这个模型属于某个函数的集合，最优则表示在某个评价准则下是最佳的），再利用这个模型将所有的输入映射为相应的输出，对输出进行简单的判断从而实现分类的目的，也就具有了对未知数据进行分类的能力。在人对事物的认识中，我们从孩子开始就被大人们教授这是鸟啊、那是猪啊、那是房子啊，等等。我们所见到的景物就是输入数据，而大人们对这些景物的判断结果（是房子还是鸟啊）就是相应的输出。当我们见识多了以后，脑子里就慢慢地得到了一些泛化的模型，这就是训练得到的那个（或者那些）函数，从而不需要大人在旁边指点的时候，我们也能分辨的出来哪些是房子，哪些是鸟。监督学习里典型的例子就是KNN、SVM。</p><h4 id="无监督学习"><a class="markdownIt-Anchor" href="#无监督学习"></a> 无监督学习</h4><p><strong>无监督学习</strong>（也有人叫非监督学习，反正都差不多）则是另一种研究的比较多的学习方法，它与监督学习的不同之处，在于我们事先没有任何训练样本，而需要直接对数据进行建模。这听起来似乎有点不可思议，但是在我们自身认识世界的过程中很多处都用到了无监督学习。比如我们去参观一个画展，我们完全对艺术一无所知，但是欣赏完多幅作品之后，我们也能把它们分成不同的派别（比如哪些更朦胧一点，哪些更写实一些，即使我们不知道什么叫做朦胧派，什么叫做写实派，但是至少我们能把他们分为两个类）。无监督学习里典型的例子就是聚类了。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了。</p><h4 id="聚类和分类的区别"><a class="markdownIt-Anchor" href="#聚类和分类的区别"></a> 聚类和分类的区别</h4><ul><li><p>聚类就是没有标准，将数据集中具有同一特征的所有数据设置成一个集合</p></li><li><p>而分类是知道数据的特征，将特征一样的设置成一个集合</p></li></ul><h4 id="强化学习马尔可夫决策"><a class="markdownIt-Anchor" href="#强化学习马尔可夫决策"></a> 强化学习（马尔可夫决策）</h4><p>这个算法可以训练程序做出某一决定。程序在某一情况下尝试所有的可能行动，记录不同行动的结果并试着找出最好的一次尝试来做决定。 属于这一类算法的有马尔可夫决策过程。</p><p><strong>马尔可夫性质</strong>是强化学习理论的基石，主要意思是，下一步的状态，只和我们当前的状态有关，而和之前的状态无关（具体以后再介绍）</p><h3 id="机器学习的使用流程"><a class="markdownIt-Anchor" href="#机器学习的使用流程"></a> 机器学习的使用流程</h3><ol><li><p>收集数据: 收集样本数据</p></li><li><p>准备数据: 注意数据的格式</p></li><li><p>分析数据: 为了确保数据集中没有垃圾数据；</p></li><li><p>如果是算法可以处理的数据格式或可信任的数据源，则可以跳过该步骤；</p></li><li><p>另外该步骤需要人工干预，会降低自动化系统的价值。</p></li><li><p>训练算法: [机器学习算法核心]如果使用无监督学习算法，由于不存在目标变量值，则可以跳过该步骤</p></li><li><p>测试算法: [机器学习算法核心]评估算法效果</p></li><li><p>使用算法: 将机器学习算法转为应用程序</p></li></ol><h2 id="机器学习的相关模块"><a class="markdownIt-Anchor" href="#机器学习的相关模块"></a> 机器学习的相关模块</h2><ul><li>Python相关的库<ul><li>科学函数库：SciPy、NumPy(底层语言：C和Fortran)</li><li>绘图工具库：Matplotlib</li><li>数据分析库 Pandas</li></ul></li></ul><h2 id="常用术语"><a class="markdownIt-Anchor" href="#常用术语"></a> 常用术语</h2><p>附：机器学习专业术语</p><ul><li><p>模型（model）：计算机层面的认知</p></li><li><p>学习算法（learning algorithm），从数据中产生模型的方法</p></li><li><p>数据集（data set）：一组记录的合集</p></li><li><p>示例（instance）：对于某个对象的描述</p></li><li><p>样本（sample）：也叫示例</p></li><li><p>属性（attribute）：对象的某方面表现或特征</p></li><li><p>特征（feature）：同属性</p></li><li><p>属性值（attribute value）：属性上的取值</p></li><li><p>属性空间（attribute space）：属性张成的空间</p></li><li><p>样本空间/输入空间（samplespace）：同属性空间</p></li><li><p>特征向量（feature vector）：在属性空间里每个点对应一个坐标向量，把一个示例称作特征向量</p></li><li><p>维数（dimensionality）：描述样本参数的个数（也就是空间是几维的）</p></li><li><p>学习（learning）/训练（training）：从数据中学得模型</p></li><li><p>训练数据（training data）：训练过程中用到的数据</p></li><li><p>训练样本（training sample）:训练用到的每个样本</p></li><li><p>训练集（training set）：训练样本组成的集合</p></li><li><p>假设（hypothesis）：学习模型对应了关于数据的某种潜在规则</p></li><li><p>真相（ground-truth）:真正存在的潜在规律</p></li><li><p>学习器（learner）：模型的另一种叫法，把学习算法在给定数据和参数空间的实例化</p></li><li><p>预测（prediction）：判断一个东西的属性</p></li><li><p>标记（label）：关于示例的结果信息，比如我是一个“好人”。</p></li><li><p>样例（example）：拥有标记的示例</p></li><li><p>标记空间/输出空间（label space）：所有标记的集合</p></li><li><p>分类（classification）：预测是离散值，比如把人分为好人和坏人之类的学习任务</p></li><li><p>回归（regression）：预测值是连续值，比如你的好人程度达到了0.9，0.6之类的</p></li><li><p>二分类（binary classification）：只涉及两个类别的分类任务</p></li><li><p>正类（positive class）：二分类里的一个</p></li><li><p>反类（negative class）：二分类里的另外一个</p></li><li><p>多分类（multi-class classification）：涉及多个类别的分类</p></li><li><p>测试（testing）：学习到模型之后对样本进行预测的过程</p></li><li><p>测试样本（testing sample）：被预测的样本</p></li><li><p>聚类（clustering）：把训练集中的对象分为若干组</p></li><li><p>簇（cluster）：每一个组叫簇</p></li><li><p>监督学习（supervised learning）：典范–分类和回归</p></li><li><p>无监督学习（unsupervised learning）：典范–聚类</p></li><li><p>未见示例（unseen instance）：“新样本“，没训练过的样本</p></li><li><p>泛化（generalization）能力：学得的模型适用于新样本的能力</p></li><li><p>分布（distribution）：样本空间的全体样本服从的一种规律</p></li><li><p>独立同分布（independent and identically distributed，简称i,i,d.）:获得的每个样本都是独立地从这个分布上采样获得的。</p></li></ul><h3 id="数据集的划分"><a class="markdownIt-Anchor" href="#数据集的划分"></a> 数据集的划分</h3><ul><li>训练集（Training set） —— 学习样本数据集，通过匹配一些参数来建立一个模型，主要用来训练模型。类比考研前做的解题大全。</li><li>验证集（validation set） —— 对学习出来的模型，调整模型的参数，如在神经网络中选择隐藏单元数。验证集还用来确定网络结构或者控制模型复杂程度的参数。类比 考研之前做的模拟考试。</li><li>测试集（Test set） —— 测试训练好的模型的分辨能力。类比 考研。这次真的是一考定终身。</li></ul><h3 id="模型拟合程度"><a class="markdownIt-Anchor" href="#模型拟合程度"></a> 模型拟合程度</h3><ul><li>欠拟合（Underfitting）：模型没有很好地捕捉到数据特征，不能够很好地拟合数据，对训练样本的一般性质尚未学好。类比，光看书不做题觉得自己什么都会了，上了考场才知道自己啥都不会。</li><li>过拟合（Overfitting）：模型把训练样本学习“太好了”，可能把一些训练样本自身的特性当做了所有潜在样本都有的一般性质，导致泛化能力下降。类比，做课后题全都做对了，超纲题也都认为是考试必考题目，上了考场还是啥都不会。</li></ul><p>通俗来说，欠拟合和过拟合都可以用一句话来说，欠拟合就是：“你太天真了！”，过拟合就是：“你想太多了！”。</p><h3 id="常见的模型指标"><a class="markdownIt-Anchor" href="#常见的模型指标"></a> 常见的模型指标</h3><ul><li>正确率 —— 提取出的正确信息条数 / 提取出的信息条数</li><li>召回率 —— 提取出的正确信息条数 / 样本中的信息条数</li><li>F 值 —— 正确率 * 召回率 * 2 / （正确率 + 召回率）（F值即为正确率和召回率的调和平均值）</li></ul><p>举个例子如下：</p><p>举个例子如下： 某池塘有 1400 条鲤鱼，300 只虾，300 只乌龟。现在以捕鲤鱼为目的。撒了一张网，逮住了 700 条鲤鱼，200 只 虾， 100 只乌龟。那么这些指标分别如下： 正确率 = 700 / (700 + 200 + 100) = 70% 召回率 = 700 / 1400 = 50% F 值 = 70% * 50% * 2 / (70% + 50%) = 58.3%</p><h2 id="参考网站推荐"><a class="markdownIt-Anchor" href="#参考网站推荐"></a> 参考网站推荐</h2><p>本博客知识来自<code>GitHub</code>上的<a href="https://ailearning.apachecn.org/#/docs/ml/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">ailearning</a></p><p>机器学习有关的数学知识请看<a href="https://zhuanlan.zhihu.com/p/25197792" target="_blank" rel="noopener">知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研初试经验</title>
    <link href="/2020/02/20/%E8%80%83%E7%A0%94%E5%88%9D%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <url>/2020/02/20/%E8%80%83%E7%A0%94%E5%88%9D%E8%AF%95%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="1前言"><a class="markdownIt-Anchor" href="#1前言"></a> 1.前言</h2><p>本人是来自江西师范大学的一名学生，考研初试科目包括英语二，数学二，政治，专业课，一共四门科目。考的方向是深圳大学电子通信专业，属于跨专业考试。接下来，我将分享下这一年来的考研心得，最后我会和大家说一些小技巧和需要注意的地方。也推荐大家多去知乎，等其他地方多学学别人的经验，适合自己的才是最有效的。在这我很感谢身边和自习室的同学，是他们给了我巨大的动力，让我坚持下来！</p><p>在这我有几句话想先对大家说下：</p><ol><li>能花钱解决的事，一定不要浪费时间。</li><li>早上去自习室不要太早或者太晚，根据自己的实际情况，效率才最重要</li></ol><h2 id="2数学考试经验"><a class="markdownIt-Anchor" href="#2数学考试经验"></a> 2.数学考试经验</h2><p>本人数学二今年126分，接下来我将分享下我个人的数学学习方法。</p><h3 id="数学复习资料如何选择"><a class="markdownIt-Anchor" href="#数学复习资料如何选择"></a> 数学复习资料如何选择</h3><hr /><p>我个人是非常推荐汤家凤老师，看视频和用资料选汤老师比较好。</p><p><strong>当时我的数学资料购买的有：</strong></p><ol><li>汤家凤复习全书</li><li>汤家凤高等数学辅导讲义</li><li>汤家凤线性代数辅导讲义</li><li>李永乐线性代数辅导讲义</li><li>汤家凤1800题</li><li>历年真题(可以买李正元或者李永乐的历年真题解析)</li><li>后期购买李林的6+4模拟卷(11月份左右才出)</li></ol><hr /><p><strong>学习的视频有：</strong></p><ol><li>汤家凤高等数学基础阶段视频</li><li>汤家凤线性代数基础阶段视频</li><li>李永乐线性代数提高阶段视频</li></ol><hr /><h3 id="学习时间的规划"><a class="markdownIt-Anchor" href="#学习时间的规划"></a> 学习时间的规划</h3><p>本人其实是大二下学期就开始准备考研的，这里着重说下数学的学习时间规划。(本人是有一定的数学基础，但是刚开始复习的时候大部分都忘记了)</p><ul><li>3月份之前，也就是寒假阶段，带了数学书回家但是看的时间不超过6个小时。所以数学可以说是2月25号才正式开始学习的。</li><li>3月份到7月份，差不多到暑假的时候，数学复习完了一遍线性代数和高等数学，并且做了两遍左右的1800<strong>基础部分</strong>，以及一遍辅导讲义**(高数和现代两本辅导讲义)**，主要是用来巩固知识点，期间每天百分之80的时间都是在学习数学的。（期间用的书只有汤老师的，听一节视频写一章节的课程，线性代数这时候没有看李永乐的）</li></ul><blockquote><p>此时每天花在数学上的时间是8-9小时</p></blockquote><ul><li>在进入暑假之前，由于学了后面差不多就把前面忘了，所以在暑假前，利用了一个星期的时间把高数和现代的基础部分又快速过了一遍</li></ul><blockquote><p>此时每天花在数学上的时间是8-9小时</p></blockquote><ul><li>正式进入暑假，意味着数学要全面进入提高阶段了，在进入提高之前，复习了一边高数基础，但是还是会有些题听不懂，但是没有关系，不懂的可以先放一放或者问问其他同学，开始写汤家凤复习全书，边看视频边写全书，期间保持做题手感，现代高数每天都写。全书题目写了三遍，李永乐线性代数看了7遍左右。（之前用的汤家凤辅导讲义没看了，暑假期间只写汤家凤全书的题目，加上李永乐现代辅导讲义的复习）</li></ul><blockquote><p>此时每天花在数学上的时间是8-9小时</p></blockquote><ul><li>全书过了两遍后，差不多就到10月份了，我是10月1号开始写历年真题的，写到11月份，留了最后两年的真题没写。做真题的时候总结错题，反复看错题，和1800的提高部分题目。</li></ul><blockquote><p>此时每天花在数学上的时间是5-6小时，就是上午一到自习室，看到下午三点</p></blockquote><ul><li>11月中旬，李林的六套卷和四套卷出来了后，开始每天一套模拟题，考前两个星期，模拟题差不多做完的话，一定要再看一遍全书，现代辅导讲义，过一遍基础，再过一遍错题。（一定要去做李林的卷子，其他的我不推荐买，后期一定要回归基础）</li></ul><blockquote><p>每天只花一个上午的时间看数学，吃完饭就不看了</p></blockquote><hr /><h3 id="数学学习小建议"><a class="markdownIt-Anchor" href="#数学学习小建议"></a> 数学学习小建议</h3><ol><li>一定会遇到不会的题目，你可以加一些数学交流群，比较活跃的那种，自己qq搜索一下就可以了，会要点钱但是不多</li><li>可以找一个网友，数学比较厉害的，一直问他题目(比如自己学校的数学竞赛群，去那里面看，加他好友，最好别人也考研)</li><li>数学错题本，我不推荐手写，这里我介绍一个ipad软件，Marginnote，去商店搜一下，当时我是购买的正版88块钱，因为觉得真的好用，他可以让你拜托抄错题的烦恼，不过缺点就是很多资料都是需要电子版的</li><li>去淘宝和咸鱼上搜一搜资料，很便宜的，不要在乎这点小钱</li><li>平时注意计算，数学计算很重要，就是多写题目，多计算</li><li><strong>反复反复再反复</strong>不要今天用这本，明天用那本，一定要反复看，现代提高我当时写了7遍！！</li><li>关于数学笔记，我自己记了好多笔记，但是最后都没什么时间看，这里推荐marginnote这款软件，让笔记电子化，手指圈一圈就可以了，省了大量时间，而且方便复习</li><li>多看几位老师的资料，可以看张宇的高数18讲，李正元的复习全书，当时我都是用的电子版，再用marginnote记录下来，方便复习，当时只做了这些资料的少部分习题</li></ol><blockquote><p>这里说下我数学走的弯路吧，3月到9月，每天我都花大量的时间在数学上，在基础阶段时，我边看汤家凤的视频，同时几乎把他的每个字都写下来了，现在感觉当时好傻，浪费了这么多时间。所以这里建议大家能够专门用一本本子，记录一些解题技巧，一定要写上自己的思考过程，这本本子将跟随你到考研前。大概十一月份的时候，数学花的时间越来越少了，考试前我甚至觉得数学上不了一百，这里说句不好听的话，数学灵感真的很重要，就算你平时模拟考试分数再高，考数学那一刻你看到题目没思路，你一样会败北，所以我建议大家一定要反复看基础，注重平时的数学解题思路分析，后期把每一张卷子都当成模拟考研对待。</p></blockquote><hr /><h2 id="3英语考试经验"><a class="markdownIt-Anchor" href="#3英语考试经验"></a> 3.英语考试经验</h2><p>本人考的英语二，成绩是67分，所以没什么话语权，但是我可以说下，让大家少走点弯路<br /><strong>视频选择：</strong></p><ol><li>陈仲恺阅读视频</li><li>微信公众号屠屠老师(每日长难句分析)</li></ol><p><strong>资料选择：</strong></p><ol><li>英语一和英语二的历年真题(考研真相)（张剑黄皮书）</li><li>英语单词新东方绿皮书</li><li>英语练字帖</li><li>王道长的考研英语作文</li></ol><h3 id="英语学习时间规划"><a class="markdownIt-Anchor" href="#英语学习时间规划"></a> 英语学习时间规划</h3><ol><li>寒假开始就可以背单词了，背单词是要从寒假就坚持到考研当天，当时我是把绿皮书背了六七遍吧，每天一小时左右就行</li><li>3月到5月，我并没有写英语阅读，就是单纯背单词，多背几个意思，<strong>记得每天练字！！</strong></li><li>5月初可以开始先把英语一的九几年的阅读开始慢慢写了，每天保持一定的阅读量，前期一天只写两篇左右，写完了看视频讲解，总结答题技巧</li><li>到了11月份，开始加大阅读题量，一次性写4篇，期间只写阅读，期间新题型和作文等都没开始（英语一的要早点，英语二的可以晚一些准备其他板块，多花点时间在数学上）</li><li>11月初要开始背小作文模板了，当时我是背的王道长的小作文，背了10篇，近几年英语二作文都是综合型的，所以10篇小作文必须全背。期间将除了阅读的其他模块逐一击破。大作文我是到处找模板，自己凑了两个框架来背，为什么我感觉今年深圳那边英语压分啊</li></ol><blockquote><p>当时我每天的英语时间不超过两个半小时，除了模拟英语考试<br />英语一的一定要早一点，建议学一下基础语法，考英语一的一定要学语法，长难句</p></blockquote><h3 id="英语学习小建议"><a class="markdownIt-Anchor" href="#英语学习小建议"></a> 英语学习小建议</h3><ol><li>前期推荐用单词书背诵，不需要默写，认识就行</li><li>后期推荐一款手机软件，anki，控制好自己，上厕所可以背单词，睡觉前瞒着室友偷偷躺在床上背单词，非常方便</li><li>英语字很重要！！！</li><li>把阅读中不会的单词记录到anki卡片中，方便复习！！！</li></ol><blockquote><p>这里说下我走的弯路，希望大家可以避免。前期我每天都背单词，到了十一月，我几乎就没背单词了，英语也是隔三岔五看看，单词一定要坚持背，阅读一定要保持手感，临近考研，你会被四门科目轮流散打，每科有重多的知识点，当时我是上午看数学，下午背政治，晚上还有专业课，英语几乎没什么时间看。考前晚上还失眠，考英语的时候看着阅读差点睡着了。所以这里我建议大家专业课一定要早一点准备（7月份左右），我是八月份才开始慢慢看的，所以感觉时间不够，前期你专业课花的时间多，后期可以挤出时间给英语。</p></blockquote><hr /><h2 id="4政治考试复习"><a class="markdownIt-Anchor" href="#4政治考试复习"></a> 4.政治考试复习</h2><p>本人政治72分，花的时间并不多，可以给大家分享下政治学习方法</p><p><strong>视频推荐：</strong></p><ol><li>徐涛或者王吉</li></ol><p><strong>资料选择：</strong></p><ol><li>肖秀荣1000题，anki版题目，不推荐纸制的</li><li>肖秀荣知识点摘要</li><li>王吉三套卷选择题，田维彬预测题，进两年政治真题，肖四肖八选择题(这些都是试卷，只写选择题)</li><li>田维彬时政（不用全看，了解即可，他有时政题目，写下有印象即可）</li></ol><h3 id="政治时间规划"><a class="markdownIt-Anchor" href="#政治时间规划"></a> 政治时间规划</h3><ol><li>我是九月份开始政治复习的，一天看两个小时视频，由于感觉后期有点点紧，所以你可以早一点看，但也不推荐太早，看一章视频用anki刷一章题目</li><li>10月底，之前要看完政治视频，自己把握时间，这时候肖8也差不多出来了，肖8出来就不要再看1000题了</li><li>11月中旬到考试前，大量刷王吉三套卷选择题，田维斌预测题，进两年政治真题，肖四肖八选择题(这些都是试卷，只写选择题)</li><li>当你写完肖4选择后，就要开始背分析题了，当时我是考前十天左右，每天花一个下午的时间，找一个安静的地方背肖四分析题，挑关键词背，但是还是好多，背的都想哭来了</li></ol><blockquote><p>时间不一定，随着临近考试，政治复习时间慢慢增加</p></blockquote><h3 id="政治学习小技巧重要"><a class="markdownIt-Anchor" href="#政治学习小技巧重要"></a> 政治学习小技巧（重要！！）</h3><ol><li>一定要记得用anki刷题哦！还是别人推荐给我的，非常好用，上厕所也可以刷政治，不会的一定要百度，因为很多概念</li><li>后期一定要刷那些老师的选择题预测卷，我先说下为什么1000题只刷一两遍，但马原要多写几遍</li></ol><ul><li>马原部分靠理解，并且很比较灵活，多选错选都没分，所以一定要把握好概念</li><li>其他题型都比较固定，容易和时事政治结合起来，1000题意义不大</li><li>你没这么多时间，政治拉分不多，没必要太多时间</li><li>那些老师的选择题预测卷非常有价值，做完我说的那些就够了，因为他们都会将当年发生的时事政治和相关知识点结合起来，比较贴近考研命题风格，强烈推荐<strong>田维彬</strong>考研政治，他的选择可以压中原题</li></ul><ol start="3"><li>分析题当时我背的是肖老师的，虽然今年不太准，由于我没太多时间，只背了肖4前两套的（主要）4套卷的马原和毛概，全背了，其他的看重不重要再背。以及部分天维彬预测卷</li><li>**考试技巧！**当时我怀疑肖的压得可能会不准，就又找了田维彬的政治押题，他们两押题都很准，不推荐其他考研机构押题。我就对比了下两位老师的分析题押题，发现大部分是一样的，但是田老师压的一些题目感觉没见过，于是我考试前，就特意看了看，记了关键词，然后进考场马上写到草稿纸上，没想到真的考到了一个小题（要知道今年肖4就没压到好像）</li><li>政治字一定要写好，总的来说就是字写好，答案全写满，我这有田维彬的学习群，也就50块钱，包括答疑和学习计划以及学习资料（上面资料里面都有），帮我节省了大量时间，想进可以联系我（QQ747876457）<strong>注意加我的时候备注</strong></li></ol><blockquote><p>本人大学就没怎么学过政治，还只是一个团员，当时9月开始政治，真的感觉时间不够，不过政治学的是最开心的，因为动脑地方不多。后期真的是背的想哭，背着背着我就打电话给自己老妈了…毕竟从小到大没背过这么多东西。我个人是很怕喧闹的环境的，当时换了很多地方背书，最后找了一个比较偏僻的地方，每天都是一个人，真的快背自闭了。考政治当天虽然失眠，但是没办法呀，拿到卷子，本来以为肖老师可以压中原题的，结果全傻眼了，分析题全程在分析题干，背的那些用的不多，光是分析题干，最后没想到也考了个70分，所以要不要背很多，你自己决定把。</p></blockquote><h2 id="5专业课"><a class="markdownIt-Anchor" href="#5专业课"></a> 5.专业课</h2><p>深大专业课是出了名的难，和我同专业的几乎全是90分左右，100以上的非常少，而且每个人专业课不一样，我在这就不多说了，但是建议大家暑假开始的时候就可以着手专业课了，专业课视频哪里看？<strong>去B站和MOOC上搜一下就可以了</strong></p><blockquote><p>这里说下深圳大学电子通信专业课，考试书目有数字电路和数字信号处理，数字电路还好，上手不是那么难，数字信号处理就不一样了，本科没学过，还巨难，傅里叶变换，拉普拉斯变换等，变到你找不到东南西北 。最难的还不是这个，深大专业课指定了两本书，意味着你只要看两本就行了，但是他不考这上面的，只能说题目太超纲了，很多题目都很新颖，改卷非常严格，只要答案错，步骤分就是没有的，所以大家专业课分普遍都不高，这里建议专业课尽量早一些开始把，历年真题可以说是有又没有帮助，是因为你看了题目以后就知道第二年不考什么了，深大就喜欢挑没考过的知识点考，但是会参入少量的重复知识点，所以你必须每个点都掌握。实在不会写的题目，可以找相关的老师帮忙，当时我是实在不会，就花了一个下午的时间找老师帮忙。虽然最后考试还是不会…</p></blockquote><h2 id="6宾馆选择"><a class="markdownIt-Anchor" href="#6宾馆选择"></a> 6.宾馆选择</h2><p>自己订宾馆就行，一定要看好位置，宾馆不要在马路旁，附近一定不要有ktv！！！</p><h2 id="7小技巧补充"><a class="markdownIt-Anchor" href="#7小技巧补充"></a> 7.小技巧补充</h2><ol><li>善用B站和MOOC</li><li>善用咸鱼和淘宝，不要不舍得花钱，这些以后都会赚回来的</li><li>不推荐经常休息</li></ol><h2 id="8后记"><a class="markdownIt-Anchor" href="#8后记"></a> 8.后记</h2><p>这里记录我的整个考研心理变化，感兴趣的可以看看，不知道是不是有人和我一样…</p><blockquote><p>三月份，我开始了数学的学习，前期参加了中公的数学培训，多亏了我室友，50块钱上了一星期的数学培训课，酒店是免费的，比较好，前期每天早上背单词，其余时间全在看数学，期间还有些课，大三下学期很多课我都是在看数学的，完全不听老师讲课，水课能不去尽量不去。就这样到了暑假，并且一直给自己打气，不就是考研吗，才几个月，自己肯定坚持的下来。在这期间，中午晚上都和同学一起吃饭，吃完晚饭还会去学校的湖边溜达半小时，每天晚上学到10点，回到寝室就开始玩手机。正式进入暑假了，这时候我还在每天看数学，别人都开始政治了，当时我感觉完全不慌，暑假完成了数学提高，进入八月，越来越多人开始政治学习了，我也在纠结要不要开始，8月20号开始，打算先看看徐涛的视频，不过这期间只看视频没做题目，看了几天就没看了，又继续把政治时间给了数学和专业课。九月开始正式刷政治，当时感觉有点慌了，因为政治好多没看，于是上厕所在看政治，睡前还在看政治，当时很多概念不会，我就一题一题百度，但是确实蛮有效果的，进入十月份，我开始失眠了，因为这时候数学英语政治专业课，每门都要看，还不知道如何分配时间，就到处问别人，看他们是如何准备的。十一月份了，失眠没有了，可能是太累了吧，躺床上就能睡着。每天都是一个人独来独往，吃饭十五分钟就解决了，开始有点没把握了，刚开始想360不是数数手指就能考到吗？写了专业课的题目后，发现我太天真了，而且数学，英语，专业课都没正式测试过，心里也没底，这时压力越来越大了。当时坐在自习室，书看着看着就发起呆来了，想着考上研究生以后或者没考上研究生该怎么办，状态感觉没之前好了。就这样，不知不觉来到考研前一个星期了，当时觉得无所谓了，爱咋地就咋地把，只想快点结束。但是又心想还有好多错题没看，太多的知识点没掌握好，而且最后几天真的是过的超级快呀，一下就到考研前一天了。提前半天去了酒店，当时上午还在自习室，第一次看到自习室少了好多人，想着马上要和这些熟面孔分离一段时间了，就有点想哭，中午吃饭还去看了看二食堂二楼的水果店老板，考研前一个晚上，真的很感谢大家祝我好运呀。第二天是考政治，英语，于是我大量时间就在背政治了，英语就把前两天模拟的19年卷子拿出来看，把握错题的感觉。十一点就准备睡觉了，但是一直没睡着，酒店就在马路旁，货车一直运货到半夜三点。第二天感觉巨困，但是考政治问题不大，mmp，下午考英语，中午就过了一遍作文，写阅读的时候感觉巨困，好想睡觉。考完英语政治后的当天晚上，几乎全在看专业课了，剩下一个小时看数学，看了半小时就感觉巨困，就睡觉了，由于之前那个房间太吵，我就换了个房间。第二天起来，我就看昨晚没看完的数学，看的李林6+4套卷，没想到真的考到了。中午就找到一个安静的吃饭地方，到考试前一直看专业书，并没睡午觉。考完真的感觉时间过得很快呀，你要相信自己一定可以的！加油哦！你一定可以的哟！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>考研经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows系统下用hexo搭建个人博客</title>
    <link href="/2020/02/20/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/20/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="windows利用hexo搭建自己的博客"><a class="markdownIt-Anchor" href="#windows利用hexo搭建自己的博客"></a> windows利用hexo搭建自己的博客</h1><h2 id="采用hexo搭建个人博客"><a class="markdownIt-Anchor" href="#采用hexo搭建个人博客"></a> 采用hexo搭建个人博客</h2><h3 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h3><ol><li>百度搜索nodejs网站，下载nodejs软件到电脑上</li></ol><hr /><ol start="2"><li>打开cmd，输入<code>npm install -g cnpm --registry-https://registry.npm.taobao.org</code></li><li>接着输入<code>cnpm</code>命令，系统会自动补全命令，输入<code>cnpm -v</code>可以查看安装的版本号。如果有输入，则安装成功</li><li>输入<code>cnpm install -g hexo-cli</code>命令，安装hexo</li><li>输入<code>mkdir blog</code>接下来会在当前目录下创建一个blog文件夹，自己可以去该目录下查看是否生成，输入<code>chdir</code>可以查看目录，会自己显示出来</li><li>此时我们继续在cmd下输入<code>hexo init</code>，会提示报错，所以我们这时候应该打开浏览器，百度搜索git，找到git的官网，下载软件到电脑上，<font color='red'>注意记得安装路径，不要随便添加</font></li></ol><hr /><ol start="7"><li><p>下载好git后，我们可以在git的安装路径下发现几个文件 <img src="http://i2.tiimg.com/710246/7b6b9af5b5aa3ce0.png" srcset="/img/loading.gif" alt="Markdown" /></p><hr /></li><li><p>接下来要添加git到环境变量，首先复制该路径，找到我的电脑，标右键点属性，再点击高级系统设置，可以看到环境变量，找到path点击编辑，将文件路径复制进去即可</p></li></ol><p><img src="http://i2.tiimg.com/710246/bac6d69fed6aa81f.png" srcset="/img/loading.gif" alt="Markdown" /><br /><img src="http://i2.tiimg.com/710246/c948c3ef2ce69d10.png" srcset="/img/loading.gif" alt="Markdown" /><br /><img src="http://i2.tiimg.com/710246/0e14c66f125c744b.png" srcset="/img/loading.gif" alt="Markdown" /><br /><img src="http://i2.tiimg.com/710246/ffd5097a0096077a.png" srcset="/img/loading.gif" alt="Markdown" /></p><ol start="9"><li><p>返回git软件安装目录下，打开git-bash软件，打开后可以看到一个类似于cmd窗口的交互界面，<font color='red'>剩下的步骤我们将会在git-bash运行</font></p></li><li><p>按步骤在git-bash里面输入下列代码,最开始我新建的blog文件目录是C:\Users\asus\blog，具体情况看个人安装目录</p><ol><li><code>cd C:</code></li><li><code>cd Users</code></li><li><code>cd asus</code></li><li><code>cd blog</code></li></ol></li><li><p>进到该目录下后，输入<code>hexo init</code>然后就会自动初始化hexo，这里需要等待一段时间，等待完后，我们找到blog目录并打开，会发现里面出现了许多文件，后面制作博客会用到, <font color='red'>不要关闭你的git-bash等下还要用到</font></p></li></ol><hr /><h2 id="启动你的blog"><a class="markdownIt-Anchor" href="#启动你的blog"></a> 启动你的blog</h2><ol><li>在git-bash中输入<code>hexo s</code>，然后可以发现你的博客端口</li></ol><pre class="highlight"><code class="">$ hexo sINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><ol start="2"><li>打开浏览器，输入<code>localhost:4000</code>就可以看到你的博客啦<font color='red'>注意不要关闭git-bash</font></li><li>按 Ctrl+C 进行下一步操作</li></ol><hr /><h2 id="写你的第一篇博客"><a class="markdownIt-Anchor" href="#写你的第一篇博客"></a> 写你的第一篇博客</h2><ol><li>在git-bash里面接着输入<code>hexo n &quot;我的第一篇博客&quot;</code>,然后他会自己创建一个markdown文件</li></ol><pre class="highlight"><code class="">$ hexo n &quot;我的第一篇博客&quot;INFO  Created: ~\blog\source\_posts\我的第一篇博客.md</code></pre><p>创建的位置是blog下的source文件夹里的_posts</p><ol start="2"><li><p>输入<code>cd source/_posts/</code>进入到该文件夹内，输入<code>dir</code>查看该文件夹里面有什么，结果发现确实生成了一个md文件，建议用Typora软件来编辑markdown文件</p></li><li><p>输入命令<code>cd ../..</code>退回到blog目录下</p></li><li><p>输入<code>hexo clearn</code>清除下数据库 和 <code>hexo g</code>就会为你生成博客，接着我们输入<code>hexo s</code>就可以打开博客了，可以看到里面有你的第一篇博客，博客我们直接在刚才的source里面编辑就可以了，刷新页面，网页里面的博客内容也会刷新</p><p><font color='red'>虽然你的博客生成了，但此时别人还是访问不了</font></p><hr /><h2 id="让别人也能访问你的博客"><a class="markdownIt-Anchor" href="#让别人也能访问你的博客"></a> 让别人也能访问你的博客</h2><p>由于刚才这样写的博客我们只能给自己看，所以我们要把自己的博客部署到网站上去，这里使用的免费方法是github，百度搜索github，登录后新建一个仓库，名字默认是下面的格式<br /><img src="http://i2.tiimg.com/710246/bc0b422db61b7e4b.png" srcset="/img/loading.gif" alt="Markdown" /><br /><img src="http://i2.tiimg.com/710246/eff483274ea75be0.png" srcset="/img/loading.gif" alt="Markdown" /><br />创建好了后，返回git-bash中，切换到blog目录下，这时我们要在blog目录下安装一个hexo插件，直接输入命令<code>cnpm install --save hexo-deployer-git</code></p></li></ol><pre class="highlight"><code class="">_config.yml  node_modules  package-lock.json  scaffolds  themesdb.json      package.json  public             source</code></pre><p>我们可以发现生成了一个_config.yml 文件，接着输入<code>notepad _config.yml</code>,电脑会用记事本打开这个文件，在文件最下面，我们可以看到一个#Deployment<br /><img src="http://i2.tiimg.com/710246/3be705fa79e51eb9.png" srcset="/img/loading.gif" alt="Markdown" /></p><p>将下面地址复制进记事本中，修改记事本中的一部分内容，按图片来操作</p><p><font color='red'><strong>注意每个冒号后要加一个空格</strong></font></p><p><img src="http://i2.tiimg.com/710246/90540aa9326a4891.png" srcset="/img/loading.gif" alt="Markdown" /><br />修改好后保存退出</p><ol start="5"><li>设置git-bash的身份<br /><code>git config --global user.name &quot;xxx&quot;</code><br /><code>git config --global user.email &quot;xxx&quot;</code><br />注意空格，或者你直接复制把xxx改成你自己的信息，名字随便取，邮箱可以是qq邮箱<br />然后输入<code>git config user.name</code>and<code>git config user.email</code>查看是否真的生成了信息</li><li>设置好gitbash的身份之后，接着输入<code>hexo d</code>，然后就会要你登录 github<br />例如我自己gitgub账号邮箱是747876457@qq.com, gitbash设置的是mcspero123@gmail.com<br />然后再用密码登录即可<br />7.登录成功后gitbash窗口就在下载东西，等待即可，下载成功后，刷新你的github仓库，会发现生成了很多新的文件</li></ol><blockquote><p>期间我输入<code>hexo d</code>然后报错了很多次，但是没关系，我们一直输入hexo d命令直到成功即可</p></blockquote><ol start="7"><li>然后拿仓库名后面的部分，直接复制到浏览器中即可访问你的博客了<br /><img src="http://i2.tiimg.com/710246/ca58a5c317e1f955.png" srcset="/img/loading.gif" alt="Markdown" /></li></ol><blockquote><p>例如我的博客地址就是https://miki123-gif.github.io/</p></blockquote><hr /><h2 id="如何自定义主题"><a class="markdownIt-Anchor" href="#如何自定义主题"></a> 如何自定义主题</h2><ol><li>下载别人的主题<br />这里下载会出现一些问题，是因为主题太大了，gitbash做了下载设置<a href="https://blog.csdn.net/dzhongjie/article/details/81152983" target="_blank" rel="noopener">可以看看这篇文章</a><br />直接先输入<code>git config --global http.postBuffer 524288000</code>就行啦<br />在git-bash窗口中，注意切换到你之前创建的blog文件夹下，输入<br /><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code><br /><a href="https://github.com/litten/hexo-theme-yilia.git%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E4%B8%AA%E5%88%AB%E4%BA%BA%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D%E7%A7%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%99%E9%87%8C%E7%94%A8%E7%9A%84%E6%98%AF%E5%88%AB%E4%BA%BA%E5%86%99%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98,%E6%8A%8A%E5%AE%83%E5%A4%8D%E5%88%B6%E5%88%B0themes%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84yilia%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%EF%BC%8C%E8%A6%81%E7%AD%89%E5%BE%85%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git其实是一个别人的仓库名称，我们这里用的是别人写的博客主题,把它复制到themes目录下的yilia文件夹内，要等待一段时间</a></li></ol><p>下载完后，退回到blog目录下，再次找到_config.yml文件，修改里面的theme成yilia<br /><img src="http://i2.tiimg.com/710246/be42d7bcf66ebd2c.png" srcset="/img/loading.gif" alt="Markdown" /></p><p>然后依次输入指令<code>hexo clean</code> <code>hexo g</code> <code>hexo s</code></p><p>就可以在localhost:4000上看到自己的博客变了一个主题</p><ol start="2"><li><p>将主题推到云端，这样别人就可以访问</p><p>退回到blog目录下，输入<code>hexo d</code>deploy一下，别人就可以看到你的主题了</p></li></ol><h2 id="点击访问我的博客"><a class="markdownIt-Anchor" href="#点击访问我的博客"></a> <a href="https://miki123-gif.github.io/" target="_blank" rel="noopener">点击访问我的博客</a></h2>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
