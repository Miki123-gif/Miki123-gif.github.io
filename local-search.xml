<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2020/03/07/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2020/03/07/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="决策树-decision-tree"><a href="#决策树-decision-tree" class="headerlink" title="决策树 decision tree"></a>决策树 decision tree</h2><blockquote><h4 id="信息熵-amp-信息增益"><a href="#信息熵-amp-信息增益" class="headerlink" title="信息熵 &amp; 信息增益"></a>信息熵 &amp; 信息增益</h4><ul><li><p>熵（entropy）： 熵指的是体系的混乱的程度，在不同的学科中也有引申出的更为具体的定义，是各领域十分重要的参量。</p></li><li><p>信息论（information theory）中的熵（香农熵）： 是一种信息的度量方式，表示信息的混乱程度，也就是说：信息越有序，信息熵越低。例如：火柴有序放在火柴盒里，熵值很低，相反，熵值很高。</p></li><li><p>信息增益（information gain）： 在划分数据集前后信息发生的变化称为信息增益。</p></li></ul></blockquote><blockquote><p>树的定义，就像族谱一样，根结点时唯一的，子树是根结点衍生出来的，当一个圈没叶子时，他就是叶结点，其他的都叫内部结点，如果一个内部结点有三片叶结点，那么这个内部结点的度就是3</p></blockquote><p>我们现在来看一个邮件分类系统，大致工作流程如下：</p><p><img src="https://camo.githubusercontent.com/7dcaa98439362b4e126996b04c039322c55894c9/687474703a2f2f646174612e617061636865636e2e6f72672f696d672f41694c6561726e696e672f6d6c2f332e4465636973696f6e547265652f2545352538362542332545372541442539362545362541302539312d2545362542352538312545372541382538422545352539422542452e6a7067" srcset="/img/loading.gif" alt="决策树-流程图"></p><ul><li>根结点是发送的邮件域名地址</li><li>叶结点是：<ul><li>无聊时需要阅读的邮件</li><li>需要及时处理的朋友文件</li><li>无需阅读的垃圾邮件</li></ul></li><li>内部结点是：包含单词曲棍球的邮件</li></ul><p>在这个系统中，根结点相当于输入的数据，内部结点表示一个特征或属性(我觉得是判断条件)，叶结点相当于分类结果</p><p><strong>决策树一般是处理一些离散的数据，比如现在有一些年龄的数据，1-100岁之间，那么我们就必须将这些数据分为几个区间，比如0-30算年轻，30-60算中年，60-100算老年</strong></p><p><img src="https://camo.githubusercontent.com/161cc47ffb524fb353e53598a692cde423451499/687474703a2f2f646174612e617061636865636e2e6f72672f696d672f41694c6561726e696e672f6d6c2f332e4465636973696f6e547265652f2545372538362542352545372539412538342545382541452541312545372541452539372545352538352541432545352542432538462e6a7067" srcset="/img/loading.gif" alt="熵的计算公式"></p><blockquote><p>信息熵的计算是，假如扔一个骰子，每个面朝上的概率都是1/6，那么prob就是1/6带进去，求和表示把所有情况都算出来再相加</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K-近邻算法</title>
    <link href="/2020/03/06/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/06/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><p>K-近邻算法，学名<strong>k nearest Neighbor(近的邻居)</strong>,简称<strong>KNN，</strong>该算法可以解决分类的问题</p><p><a href="https://www.bilibili.com/video/av37947862/?p=41" target="_blank" rel="noopener">推荐一个视频，讲的很详细</a></p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>训练算法，需要先用一些已知样本进行训练</p></li><li><p>将未知分类的实例(样本)输入到算法中，并且设置k值，一般k设置成奇数</p></li><li><p>完成分类</p></li></ol><h2 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h2><ol><li>假如现在我们要将一部电影归类为是<strong>爱情电影 or 动作电影</strong>，我们用两个指标来判定<strong>一部电影中的打斗次数，一部电影中的接吻次数</strong></li><li>现在我们有一些已知类别的电影，和一些未知类别的电影，我们先将已知类别的电影放入到算法中进行训练，假如打斗次数是x，接吻次数是y，我们可以明显在坐标轴上看到打斗电影的点比较密集，爱情电影的点也比较密集，图上的点集分成两类</li><li>设置k值，并且将未排序的数据，投入到算法中，开始进行分类，先从第一个未分类点开始，计算所有已知样本点到该点的距离，找k个离该点最近的点，假如k=5，里面有3个点是爱情电影，2个点是动作电影，<strong>按照少数服从多数原则</strong>，该电影就会归类到爱情电影<blockquote><ul><li>k一般取奇数是因为，假如k = 4，爱情电影和动作电影点分别有两个，那么这个电影就不好分类了</li><li>计算距离一般是算欧氏距离，即sqrt((x2-x1)^2 + (y2-y1)^2)，如果是三位的，依旧如此</li></ul></blockquote></li></ol><h2 id="算法缺点"><a href="#算法缺点" class="headerlink" title="算法缺点"></a>算法缺点</h2><ul><li>时间复杂度比较大，因为数据一多，比如未知样本有100，已知样本有100，则需要计算10000次，第一个样本需要计算他与100个样本的距离，要这样计算100次</li><li>分类不稳定，假如动作电影有100部，爱情电影有1000部，假如我们认为看一个未分类样本，应该是动作电影，但将他放入到算法中，设置k值为10时，由于动作电影稀疏，离他近的点有4个，但爱情电影多，很小范围就有6个点，那么这个点就会误认为时爱情电影</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2020/03/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg" target="_blank" rel="noopener">排序算法的动画在这里</a>，概念讲的很透彻</p><p>由于上面的排序代码是java写的，所以这里我会用python来实现一遍</p><h2 id="什么是内部排序，什么是外部排序"><a href="#什么是内部排序，什么是外部排序" class="headerlink" title="什么是内部排序，什么是外部排序"></a>什么是内部排序，什么是外部排序</h2><ul><li>内部排序指的是在内存 里面进行的排序</li><li>外部排序是当数据很大，内存存放不了的时候，需要用到外存进行数据排序</li></ul><h2 id="什么是排序算法的稳定性"><a href="#什么是排序算法的稳定性" class="headerlink" title="什么是排序算法的稳定性"></a>什么是排序算法的稳定性</h2><p>通俗地说就是假如数据中有很多同样大小的数据，在排序中，如果这些数据的<strong>相对次序</strong>不会发生变化，则称这个排序算法是稳定的</p><blockquote><p><strong>相对次序</strong>是指排序前，你在我左边，排序后，你依旧在我左边</p></blockquote><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><h3 id="算法步骤（假设从小到大排序）"><a href="#算法步骤（假设从小到大排序）" class="headerlink" title="算法步骤（假设从小到大排序）"></a>算法步骤（假设从小到大排序）</h3><ol><li>比较第一个和第二个数，如果第一个大于第二个，则交换两个数据位置</li><li>再比较第二个和第三个，重复交换步骤，执行一轮后，最右边应该存放着最大的数</li><li>进行一轮后，重复1，2步骤，但是不用比较最后一个数字</li><li>重复多轮，完成冒泡排序</li></ol><h3 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">list1 &#x3D; [5, 4, 3, 2, 1]</span><br><span class="line"></span><br><span class="line">def rank(list1):</span><br><span class="line">    # 2个数据只要排一轮，3个数据只要排两轮,这里需要四轮</span><br><span class="line">    for i in range(1, len(list1)):</span><br><span class="line">        for j in range(len(list1) - i):</span><br><span class="line">            if list1[j] &gt; list1[j + 1]:</span><br><span class="line">                temp &#x3D; list1[j]</span><br><span class="line">                list1[j] &#x3D; list1[j + 1]</span><br><span class="line">                list1[j + 1] &#x3D; temp</span><br><span class="line">    return list1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(rank(list1))</span><br></pre></td></tr></table></figure><h3 id="代码改进"><a href="#代码改进" class="headerlink" title="代码改进"></a>代码改进</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list1 &#x3D; [5, 4, 3, 2, 1]</span><br><span class="line"></span><br><span class="line">def rank(list1):</span><br><span class="line">    for i in range(1, len(list1)):</span><br><span class="line">        for j in range(len(list1) - i):</span><br><span class="line">            if list1[j] &gt; list1[j + 1]:</span><br><span class="line">                list1[j], list1[j + 1] &#x3D; list1[j + 1], list1[j]</span><br><span class="line">    return list1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(rank(list1))</span><br></pre></td></tr></table></figure><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>首先在未排序的数组中，找到最小的那一个，和第一个交换位置</li><li>在剩下的数组中，找到最小的，排在第二位</li><li>排序好的，可以不用再查找最小的那个数了</li><li>重复，知道排序完成</li></ol><h3 id="python实现算法"><a href="#python实现算法" class="headerlink" title="python实现算法"></a>python实现算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">list1 &#x3D; [5, 4, 3, 2, 1]</span><br><span class="line"></span><br><span class="line">def rank(list1):</span><br><span class="line">    temp &#x3D; 0</span><br><span class="line">    for each in range(len(list1) - 1):</span><br><span class="line">        for i in range(len(list1) - 1):</span><br><span class="line">            if list1[i] &gt; list1[i + 1]:</span><br><span class="line">                #找到最小的那个，将他的下标存储在temp中，这里的temp是局部变量，所以在最开始让他赋值为0</span><br><span class="line">                temp &#x3D; i + 1</span><br><span class="line">        new &#x3D; list1[each]</span><br><span class="line">        list1[each] &#x3D; list1[temp]</span><br><span class="line">        list1[temp] &#x3D; new</span><br><span class="line">    return list1</span><br><span class="line"></span><br><span class="line">print(rank(list1))</span><br></pre></td></tr></table></figure><h3 id="代码改进-1"><a href="#代码改进-1" class="headerlink" title="代码改进"></a>代码改进</h3><blockquote><p>在上面的代码中，根本就不需要使用到交换顺序这个方法，此外，排序好的就不用再检查了,</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#96;list1[each], list1[temp] &#x3D; list1[temp], list1[each]&#96;相当于</span><br><span class="line">new &#x3D; list1[each]</span><br><span class="line">list1[each] &#x3D; list1[temp]</span><br><span class="line">list1[temp] &#x3D; new</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">list1 &#x3D; [5, 4, 7, 3, 2, 1]</span><br><span class="line"></span><br><span class="line">def rank(list1):</span><br><span class="line">    temp &#x3D; 0</span><br><span class="line">    for each in range(len(list1) - 1):</span><br><span class="line">        for i in range(each, len(list1) - 1):</span><br><span class="line">            if list1[i] &gt; list1[i + 1]:</span><br><span class="line">                #找到最小的那个，将他的下标存储在temp中，这里的temp是局部变量，所以在最开始让他赋值为0</span><br><span class="line">                temp &#x3D; i + 1</span><br><span class="line">        list1[each], list1[temp] &#x3D; list1[temp], list1[each]</span><br><span class="line">        #等号号右边和左边不影响,只要保证temp&#x3D;each，each&#x3D;temp即可</span><br><span class="line">    return list1</span><br><span class="line"></span><br><span class="line">print(rank(list1))</span><br></pre></td></tr></table></figure><h2 id="插入排序法"><a href="#插入排序法" class="headerlink" title="插入排序法"></a>插入排序法</h2><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>现给出一个数组，将第0个看成是有序的，剩下的看成是未排序的</li><li>扫描未排序的第一个，将他插入到已排序中的合适的位置(和他之前那个比较，如果大小不对，则交换两者位置，每交换一次，temp不断向前移动一次，知道位置正确)</li><li>继续扫描未排序的第一个，重复步骤2，直到排序完成</li></ol><h3 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list1 &#x3D; [3, 1, 3, 22, 23, 1]</span><br><span class="line"></span><br><span class="line">for i in range(1, len(list1)):</span><br><span class="line">    temp &#x3D; i</span><br><span class="line">    for j in range(0, i):</span><br><span class="line">        if list1[temp] &lt; list1[i - 1 - j]:</span><br><span class="line">        #这里需要temp存储交换后的位置，每交换一次减1，且每次只和之前的1个比较</span><br><span class="line">            list1[temp - 1], list1[temp] &#x3D; list1[temp], list1[temp - 1]</span><br><span class="line">            temp -&#x3D; 1</span><br><span class="line"></span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与时间复杂度</title>
    <link href="/2020/03/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2020/03/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>数据结构，顾名思义，就是数据的存储方式</p><ul><li><p>常见的有数组，可以想象成一个个抽屉，数组就是这样，每个数据紧靠在一起，并且分配有一定的空间</p></li><li><p>链表，就像数组一样，但是每个抽屉还存放着指向下一个抽屉的地址</p></li></ul><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>由于一个问题对应多个算法，要区分算法的好坏就需要讨论算法的时间复杂度和空间复杂度</p><blockquote><ul><li>在计算机程序中，通常我们可以用end - star 来计算程序运行的时间，但是由于程序一般运行时间很短，两个算法运行的时间可能看不出差别，所以这里可以使用for循环几万次来观察时间长短</li></ul></blockquote><p>时间复杂度O表示法</p><blockquote><ul><li>定义为随着处理数据的变化，程序运行的时间是如何变化的，这里类似于极限的思想，我们知道在数据趋于无穷大的时候，要抓大头，例如一个数据时间复杂度满足t = n^2/2+n，我们可以先将n约掉，只看n^2/2，进一步，我们可表示成O(n^2)，通常很坐标表示数据量n，纵坐标表示所消耗的时间t</li><li>O(1)表示时间复杂度是常数，比如数组，我们只要计算偏移量，也就是第0个加一下就行，就算数据再大，依旧只是加一下而已</li><li>O(n)比如链表，要查找链表中的数据，我们需要从第一个往后面查找，假如每找一个需要花费1秒，那么只要数据量一旦加大，时间呈t = n增长，所以时间复杂度为O(n)</li><li>一层for循环的时间复杂度是O(n)，两层就是O(m^n)，因为每个都要循环m次，n个m相乘</li><li>常见的算法时间复杂度由小到大依次为：<strong><em>\</em>Ο(1)＜Ο(log*2n*)＜Ο(n)＜Ο(nlog*2n*)＜Ο(*n*2)＜Ο(*n*3)＜…＜Ο(*2*n)＜Ο(n!)**</strong></li></ul></blockquote><p>如何表示时间复杂度</p><ul><li>找出算法中的基本语句；</li></ul><p>　　算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。</p><ul><li>计算基本语句的执行次数的数量级；</li></ul><p>　　只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。</p><ul><li>用大Ο记号表示算法的时间性能。</li></ul><p>　　将基本语句执行次数的数量级放入大Ο记号中。</p><p>　　如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">　　       x++;</span><br><span class="line">　　<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">　     　<span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">　　          x++;</span><br></pre></td></tr></table></figure><p>　　第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(<em>n</em>2)，则整个算法的时间复杂度为<strong>Ο(n+<em>n</em>2)=Ο(<em>n</em>2)</strong>。</p><p>　　Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中<strong>Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n^2)和Ο(n^3)</strong>称为多项式时间，<strong>而Ο(2^n)和Ο(n!)称为指数时间</strong>。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为<strong>P（Polynomial,多项式）类问题</strong>，而把后者（即指数时间复杂度的算法）称为（ 非确定多项式）问题。</p><h2 id="算法时间复杂度分析法则"><a href="#算法时间复杂度分析法则" class="headerlink" title="算法时间复杂度分析法则"></a>算法时间复杂度分析法则</h2><blockquote><ul><li><p>对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间</p></li><li><p>对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下”求和法则”</p></li><li><p><strong>求和法则</strong>:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n)))  特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))</p></li><li><p>对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间</p></li><li><p>对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下”乘法法则”</p></li><li><p><strong>乘法法则</strong>: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1<em>T2=O(f(n)</em>g(n))</p></li></ul></blockquote><ul><li><strong>O(1)</strong></li></ul><blockquote><p>   Temp=i; i=j; j=temp;          </p><p>以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。<strong>注意：如果算法的执行时间不随着问题规模\</strong>n*<em>的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是*</em>O(1)*<em>。*</em></p></blockquote><ul><li><strong>O(n^2)</strong></li></ul><blockquote><p>交换i和j的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span>；                 （一次）</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)     （n+<span class="number">1</span>次）</span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++) （n2次）</span><br><span class="line">    sum++；            （n2次） </span><br></pre></td></tr></table></figure><pre><code>解：因为Θ(2\*n^2+n+1)=n^2（即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(n^2)；</code></pre></blockquote><ul><li><p><strong>O(log n)</strong>表示以2为底的log</p><p>   i=1;     ①<br>  while (i&lt;=n)</p><pre><code>i=i*2; ②</code></pre><blockquote><p>语句1的频度是1, </p><pre><code>设语句2的频度是f(n),  则：2^f(n)&lt;=n;f(n)&lt;=**log\*2n\***  取最大值f(n)=**log\*2n\***,T(n)=O(**log\*2n\*** )</code></pre></blockquote></li></ul><p><img src="https://img-blog.csdn.net/20130920172327687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvem9sYWxhZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习数学基础</title>
    <link href="/2020/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>首先这里推荐一个<a href="https://zhuanlan.zhihu.com/p/25197792" target="_blank" rel="noopener">数学基础教程</a>，里面介绍了大部分的机器学习需要用到的数学知识</p><p>推荐下知乎上作者<a href="https://www.zhihu.com/lives/926880054670159872" target="_blank" rel="noopener">跨行业转机器学习的live</a></p><p>下面我将筛选一些比较重要的知识</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>一个向量就是一列数，这些数是有序排列的。我们可以把向量看作空间中的点，每个元素是不同的坐标轴上的坐标。</p><h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><p>张量其实就像在x，y轴上突然引进一个z轴一样，通俗一点理解的话，我们可以将标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶张量。当然我们还可以将这一定义继续扩展，即：我们可以用四阶张量表示一个包含多张图片的数据集，这四个维度分别是：图片在数据集中的编号，图片高度、宽度，以及色彩数据。</p><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p><strong>有时我们需要衡量一个向量的大小。</strong>在机器学习中，我们经常使用被称为范数(norm) 的函数衡量矩阵大小。</p><ul><li><p>L1范数<img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+%5Cleft%7C+x+%5Cright%7C+%5Cright%7C+" srcset="/img/loading.gif" alt="[公式]">：为x向量各个元素绝对值之和；</p></li><li><p>L2范数<img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+%5Cleft%7C+x+%5Cright%7C+%5Cright%7C+_%7B2%7D+" srcset="/img/loading.gif" alt="[公式]">：为x向量各个元素平方和的开方。</p><p><strong>百度百科了一下，发现看不懂，这个挺重要的，先记住再说</strong></p></li></ul><h2 id="奇异值分解（Singular-Value-Decomposition，SVD）"><a href="#奇异值分解（Singular-Value-Decomposition，SVD）" class="headerlink" title="奇异值分解（Singular Value Decomposition，SVD）"></a><strong>奇异值分解（Singular Value Decomposition，SVD）</strong></h2><p>矩阵的特征分解是有前提条件的，那就是只有对可对角化的矩阵才可以进行特征分解。但实际中很多矩阵往往不满足这一条件，甚至很多矩阵都不是方阵，就是说连矩阵行和列的数目都不相等。这时候怎么办呢？人们将矩阵的特征分解进行推广，得到了一种叫作“矩阵的奇异值分解”的方法，简称SVD。通过奇异分解，我们会得到一些类似于特征分解的信息。</p><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>贝叶斯公式贯穿了机器学习中随机问题分析的全过程。从文本分类到概率图模型，其基本分类都是贝叶斯公式。</p><h3 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h3><p><a href="[https://baike.baidu.com/item/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F](https://baike.baidu.com/item/全概率公式)">百度百科</a></p><p>全概率公式为<a href="https://baike.baidu.com/item/概率论/829122" target="_blank" rel="noopener">概率论</a>中的重要公式，它将对一复杂事件A的概率求解问题转化为了在不同情况下发生的简单事件的概率的求和问题。</p><p>内容：如果事件B1、B2、B3…Bn 构成一个完备事件组，即它们两两互不相容，其和为全集；并且P（Bi)大于0，则对任一事件A有</p><p>P(A)=P(A|B1)P(B1) + P(A|B2)P(B2) + … + P(A|Bn)P(Bn)。</p><p>或者：p(A)=P(AB1)+P(AB2)+…+P(ABn))，其中A与Bn的关系为交)。</p><h3 id="先验概率"><a href="#先验概率" class="headerlink" title="先验概率"></a>先验概率</h3><p><a href="[https://baike.baidu.com/item/%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87](https://baike.baidu.com/item/先验概率)">百度百科</a></p><p>先验概率（prior probability）是指根据以往经验和分析得到的概率，如全概率公式，它往往作为”由因求果”问题中的”因”出现的概率。</p><h3 id="后验概率"><a href="#后验概率" class="headerlink" title="后验概率"></a>后验概率</h3><p><a href="[https://baike.baidu.com/item/%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87](https://baike.baidu.com/item/后验概率)">百度百科</a></p><p>事情还没有发生，要求这件事情发生的可能性的大小，是<strong>先验概率</strong>。事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，是<strong>后验概率</strong>。</p><p>假设某种病在人群中的发病率是0.001，即1000人中大概会有1个人得病，则有： <strong>P(患病) = 0.1%</strong>；即：在没有做检验之前，我们预计的患病率为<strong>P(患病)=0.1%</strong>，这个就叫作<strong>“先验概率”</strong>。</p><p>现在我们想知道的是：在做完检测显示为阳性后，某人的患病率<strong>P(患病|显示阳性)</strong>，这个其实就称为<strong>“后验概率”。</strong></p><p>这里先了解<strong>条件概率公式</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+B%7CA+%5Cright%29%3D%5Cfrac%7BP%5Cleft%28+AB+%5Cright%29%7D%7BP%5Cleft%28+A+%5Cright%29%7D+%2C+P%5Cleft%28+A%7CB+%5Cright%29%3D%5Cfrac%7BP%5Cleft%28+AB+%5Cright%29%7D%7BP%5Cleft%28+B+%5Cright%29%7D" srcset="/img/loading.gif" alt="[公式]"></p><p>由条件概率可以得到<strong>乘法公式</strong>：</p><p>乘法公式就是<strong>P(AB)</strong></p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+AB+%5Cright%29%3DP%5Cleft%28+B%7CA+%5Cright%29P%5Cleft%28+A+%5Cright%29%3DP%5Cleft%28+A%7CB+%5Cright%29P%5Cleft%28+B+%5Cright%29" srcset="/img/loading.gif" alt="[公式]"></p><p>将条件概率公式和乘法公式结合可以得到：</p><p><strong>这里说明由先验公式可以算出后验公式</strong></p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+B%7CA+%5Cright%29%3D%5Cfrac%7BP%5Cleft%28+A%7CB+%5Cright%29%5Ccdot+P%5Cleft%28+B+%5Cright%29%7D%7BP%5Cleft%28+A+%5Cright%29%7D" srcset="/img/loading.gif" alt="[公式]"></p><p>再由<strong>全概率公式</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+A+%5Cright%29%3D%5Csum_%7Bi%3D1%7D%5E%7BN%7D%7BP%5Cleft%28+A%7CB_%7Bi%7D+%5Cright%29+%5Ccdot+P%5Cleft%28+B_%7Bi%7D%5Cright%29%7D+" srcset="/img/loading.gif" alt="[公式]"></p><p>代入可以得到<strong>贝叶斯公式</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+B_%7Bi%7D%7CA+%5Cright%29%3D%5Cfrac%7BP%5Cleft%28+A%7CB_%7Bi%7D+%5Cright%29%5Ccdot+P%5Cleft%28+B_%7Bi%7D+%5Cright%29%7D%7B%5Csum_%7Bi%3D1%7D%5E%7BN%7D%7BP%5Cleft%28+A%7CB_%7Bi%7D+%5Cright%29+%5Ccdot+P%5Cleft%28+B_%7Bi%7D%5Cright%29%7D+%7D" srcset="/img/loading.gif" alt="[公式]"></p><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>概率中，方差用来衡量随机变量与其数学期望之间的偏离程度；统计中的方差为样本方差，<strong>是各个样本数据分别与其平均数之差的平方和的平均数</strong>。数学表达式如下：</p><p><img src="https://www.zhihu.com/equation?tex=Var%5Cleft%28+x+%5Cright%29+%3DE%5Cleft%5C%7B+%5Cleft%5B+x-E%5Cleft%28+x+%5Cright%29+%5Cright%5D+%5E%7B2%7D+%5Cright%5C%7D+%3DE%5Cleft%28+x%5E%7B2%7D+%5Cright%29+-%5Cleft%5B+E%5Cleft%28+x+%5Cright%29+%5Cright%5D+%5E%7B2%7D+" srcset="/img/loading.gif" alt="[公式]"></p><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>在概率论和统计学中，数学期望是试验中每次可能结果的概率乘以其结果的总和。它是最基本的数学特征之一，反映随机变量平均值的大小。</p><p>假设X是一个离散随机变量，其可能的取值有：<img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B+x_%7B1%7D+%2Cx_%7B2%7D+%2C......%2Cx_%7Bn%7D+%5Cright%5C%7D+" srcset="/img/loading.gif" alt="[公式]">)，各个取值对应的概率取值为：<img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+x_%7Bk%7D+%5Cright%29+%2C+k%3D1%2C2%2C......%2Cn" srcset="/img/loading.gif" alt="[公式]">，则其数学期望被定义为：</p><p><img src="https://www.zhihu.com/equation?tex=E%5Cleft%28X+%5Cright%29+%3D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%7Bx_%7Bk%7D+P%5Cleft%28+x_%7Bk%7D+%5Cright%29+%7D+" srcset="/img/loading.gif" alt="[公式]"></p><p>假设X是一个连续型随机变量，其概率密度函数为<img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+x+%5Cright%29+" srcset="/img/loading.gif" alt="[公式]">则其数学期望被定义为：</p><p><strong>也就是求和换成积分了</strong></p><p><img src="https://www.zhihu.com/equation?tex=E%5Cleft%28+x+%5Cright%29+%3D%5Cint_%7B-%5Cvarpi+%7D%5E%7B%2B%5Cvarpi+%7D+xf%5Cleft%28+x+%5Cright%29+dx" srcset="/img/loading.gif" alt="[公式]"></p><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><h5 id="协方差其意义：看这-超详细"><a href="#协方差其意义：看这-超详细" class="headerlink" title="协方差其意义：看这,超详细"></a><strong>协方差</strong>其意义：<a href="https://blog.csdn.net/GoodShot/article/details/79940438" target="_blank" rel="noopener">看这,超详细</a></h5><p><strong>度量各个维度偏离其均值的程度。协方差的值如果为正值，则说明两者是正相关的(从协方差可以引出“相关系数”的定义)，结果为负值就说明负相关的，如果为0，也是就是统计上说的“相互独立”。</strong></p><p>在概率论和统计学中，协方差被用于衡量两个随机变量X和Y之间的总体误差。数学定义式为：</p><p><img src="https://www.zhihu.com/equation?tex=Cov%5Cleft%28+X%2CY+%5Cright%29+%3DE%5Cleft%5B+%5Cleft%28+X-E%5Cleft%5B+X+%5Cright%5D+%5Cright%29+%5Cleft%28+Y-E%5Cleft%5B+Y+%5Cright%5D+%5Cright%29+%5Cright%5D+%3DE%5Cleft%5B+XY+%5Cright%5D+-E%5Cleft%5B+X+%5Cright%5D+E%5Cleft%5B+Y+%5Cright%5D+" srcset="/img/loading.gif" alt="[公式]"></p><h2 id="泊松分布-amp-amp-指数分布"><a href="#泊松分布-amp-amp-指数分布" class="headerlink" title="泊松分布&amp;&amp;指数分布"></a>泊松分布&amp;&amp;指数分布</h2><p><a href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html" target="_blank" rel="noopener">阮一峰的博客，讲的很详细</a></p><ul><li>泊松分布<ul><li>日常生活中，大量事件是有固定频率的。</li></ul></li></ul><p>某医院平均每小时出生3个婴儿<br>某公司平均每10分钟接到1个电话<br>某超市平均每天销售4包xx牌奶粉<br>某网站平均每分钟有2次访问<br>它们的特点就是，我们可以预估这些事件的总数，但是没法知道具体的发生时间。已知平均每小时出生3个婴儿，请问下一个小时，会出生几个？</p><p><strong>泊松分布就是描述某段时间内，事件具体的发生概率。</strong></p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+N%5Cleft%28+t+%5Cright%29+%3Dn+%5Cright%29+%3D%5Cfrac%7B%5Cleft%28+%5Clambda+t+%5Cright%29+%5E%7Bn%7De%5E%7B-%5Clambda+t%7D+%7D%7Bn%21%7D+" srcset="/img/loading.gif" alt="[公式]"></p><p>其中：</p><p>P表示概率，N表示某种函数关系，t表示时间，n表示数量，1小时内出生3个婴儿的概率，就表示为 P(N(1) = 3) ；λ 表示事件的频率。</p><p>还是以上面医院平均每小时出生3个婴儿为例，则<img src="https://www.zhihu.com/equation?tex=%5Clambda+%3D3" srcset="/img/loading.gif" alt="[公式]">；</p><p>那么，接下来两个小时，一个婴儿都不出生的概率可以求得为：</p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+N%5Cleft%282+%5Cright%29+%3D0+%5Cright%29+%3D%5Cfrac%7B%5Cleft%28+3%5Ccdot+2+%5Cright%29+%5E%7Bo%7D+%5Ccdot+e%5E%7B-3%5Ccdot+2%7D+%7D%7B0%21%7D+%5Capprox+0.0025" srcset="/img/loading.gif" alt="[公式]"></p><p>同理，我们可以求接下来一个小时，至少出生两个婴儿的概率：</p><p><img src="https://www.zhihu.com/equation?tex=P%5Cleft%28+N%5Cleft%28+1+%5Cright%29+%5Cgeq+2+%5Cright%29+%3D1-P%5Cleft%28+N%5Cleft%28+1+%5Cright%29%3D0+%5Cright%29+-+P%5Cleft%28+N%5Cleft%28+1+%5Cright%29%3D1+%5Cright%29%5Capprox+0.8" srcset="/img/loading.gif" alt="[公式]"></p><p><strong>指数分布是事件的时间间隔的概率。</strong>下面这些都属于指数分布。</p><blockquote><ul><li>婴儿出生的时间间隔</li><li>来电的时间间隔</li><li>奶粉销售的时间间隔</li><li>网站访问的时间间隔</li></ul></blockquote><p>指数分布的公式可以从泊松分布推断出来。如果下一个婴儿要间隔时间 t ，就等同于 t 之内没有任何婴儿出生。</p><ul><li>接下来15分钟，会有婴儿出生的概率是52.76%。</li><li>接下来的15分钟到30分钟，会有婴儿出生的概率是24.92%。</li></ul><p>未完待续。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希图 and 移动窗口</title>
    <link href="/2020/03/03/leetcode%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <url>/2020/03/03/leetcode%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目1-两数之和"><a href="#题目1-两数之和" class="headerlink" title="题目1 两数之和"></a>题目1 两数之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">2</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>]</span><br><span class="line">target = <span class="number">9</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> list1[list1.index(i) + <span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i + j == target:</span><br><span class="line">                <span class="keyword">return</span> print([list1.index(i), list1.index(j)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find()</span><br></pre></td></tr></table></figure><h3 id="算法-哈希字典查找"><a href="#算法-哈希字典查找" class="headerlink" title="算法 哈希字典查找"></a>算法 哈希字典查找</h3><blockquote><p><strong>什么是哈希图呢，python中的字典就是用的哈希图来查找，假设我们现在有5个抽屉，序号为0，1，2，3，4，现在一个对象key，经过哈希算法，会生成一个固定长度的数字，这个数字mod5，求出假如余数是1，那么这个数据value对应的就会存放在1这个抽屉中，假如这时候又一个数据余数是1，这个数据也会存放在1中，所以python中的字典不允许有两个一样的key，否则会更新这里面存储的数据</strong></p></blockquote><ol><li>暴力搜索法</li></ol><blockquote><p> 我的思路就是暴力搜索法，利用两层循环结构，只要找到答案，就马上return结束</p></blockquote><ol start="2"><li>哈希字典查找</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list1 &#x3D; [4, 11, 11, 15, 0, 4, 0, 3, 7]</span><br><span class="line">target &#x3D; 8</span><br><span class="line">def find():</span><br><span class="line">    hash &#x3D; &#123;&#125;</span><br><span class="line">    for key, value in enumerate(list1):</span><br><span class="line">        if target - value in hash:</span><br><span class="line">            return [hash[target - value], key]</span><br><span class="line">        hash[value] &#x3D; key   #这句不能放在if前面,防止target-num &#x3D; num,这样就不会包括自身</span><br><span class="line"></span><br><span class="line">print(find())</span><br></pre></td></tr></table></figure><p>这里涉及到的知识：</p><ol><li><p>enumerate函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enumerate([1,2])</span><br><span class="line">Out[3]: &lt;enumerate at 0x16b8c273cc8&gt;</span><br><span class="line">list(enumerate([1, 2]))</span><br><span class="line">Out[4]: [(0, 1), (1, 2)]</span><br><span class="line">for i, n in enumerate([1,2,3]):</span><br><span class="line">  ...:    print(i, n)</span><br><span class="line">  ...:    </span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>本题目是要寻找两数之和，并且返回下标，而字典是哈希，这样可以直接找到，即如果<code>target - num</code>在字典中，说明找到了，然后就可以直接返回</p></li><li><p>首先我们创建一个空的字典，然后for循环遍历，每循环一次，就往字典中加入这个数字，例如target = 9，现在有个2，则只要判断7在不在字典中即可，因为第一次为空，肯定不在的，循环一次后字典还有2，接下来假如轮到7，9-7=2，判断2是不是在字典中，发现之前字典存了2，所以直接输出就行了</p></li><li><p>注意这里<code>hash[value] = key</code> #这句不能放在if前面,防止<code>target-num = num</code>,这样就不会包括自身</p></li><li><p><code>if target - value in hash:</code>这里只能判断键在不在里面，<code>hash[value] = key</code>所以我这里换了个位置相当于2是0号位置{2：0}</p><h3 id="知识补充，python字典与哈希的关系"><a href="#知识补充，python字典与哈希的关系" class="headerlink" title="知识补充，python字典与哈希的关系"></a>知识补充，python字典与哈希的关系</h3><p>Python 调用内部的散列函数，将键（Key）作为参数进行转换，得到一个唯一的地址（这也就解释了为什么给相同的键赋值会直接覆盖的原因，因为相同的键转换后的地址是一样滴），然后将值（Value）存放到该地址中。</p></li></ol><p>对于 Python 来说，键（Key）必须是可哈希的，换句话说就是要可以通过散列函数计算出唯一地址的。那如果拿一个变量当键（Key）可以吗？肯定不行。因为变量随时都可能改变，不符合可哈希原则！</p><p>同样的，列表、字典、集合这些都是可变的，所以都不能做为键（Key）来使用。</p><p>那有朋友可能会问，那元祖呢？元祖总该是不变的吧？</p><p>其实不然，因为元祖里边可以存放列表这类可变因素，所以如果实在想拿元祖当字典的键（Key），那必须对元祖做限制：元组中只包括像数字和字符串这样的不可变元素时，才可以作为字典中有效的键（Key）。</p><p>另外还需要注意的一点是，Python 的哈希算法对相同的值计算得到的结果是一样的，也就是说 12315 和 12315.0 的值相同，他们被认为是相同的键（Key）。</p><h2 id="题目三-无重复字符的最长字符串"><a href="#题目三-无重复字符的最长字符串" class="headerlink" title="题目三 无重复字符的最长字符串"></a>题目三 无重复字符的最长字符串</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plain"><figcaption><span>最长子串 的长度。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h3 id="算法-移动窗口"><a href="#算法-移动窗口" class="headerlink" title="算法 移动窗口"></a>算法 移动窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &#39;abcabacda&#39;</span><br><span class="line">str1 &#x3D; &#39;&#39;</span><br><span class="line">list1 &#x3D; []</span><br><span class="line">for each_str in s:</span><br><span class="line">    if each_str not in str1:</span><br><span class="line">        str1 +&#x3D; each_str</span><br><span class="line">        list1.append(len(str1))</span><br><span class="line">    else:</span><br><span class="line">        str1 &#x3D; str1[str1.index(each_str) + 1:] + each_str</span><br><span class="line">print(max(list1))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line">abc</span><br><span class="line">bac</span><br><span class="line">bacd</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="错误解法"><a href="#错误解法" class="headerlink" title="错误解法"></a>错误解法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &#39;abcabacda&#39;</span><br><span class="line">str1 &#x3D; &#39;&#39;</span><br><span class="line">list1 &#x3D; []</span><br><span class="line">for each_str in s:</span><br><span class="line">    if each_str not in str1:</span><br><span class="line">        str1 +&#x3D; each_str</span><br><span class="line">        list1.append(len(str1))</span><br><span class="line">        print(str1)</span><br><span class="line">    else:</span><br><span class="line">        str1 &#x3D; str1[1:] + each_str</span><br><span class="line">print(max(list1))</span><br><span class="line">a</span><br><span class="line">ab</span><br><span class="line">abc</span><br><span class="line">abac</span><br><span class="line">abacd</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>什么是移动窗口？给你一串数据，可以是列表或者字符串，设置一个小窗口，从左到右不断移动，也就是左边出，右边进，这题规定不能有重复的出现，所以<code>str1 = str1[1:] + each_str</code>这样不断左移一个是不行的<code>abac</code>必须在重复的位置，前面出现a的左边全部切掉，切掉后数据长度必定减短</p><p>这里附上最好的解法，运算时间和占用内存都是最低的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &#39;abcabacd&#39;</span><br><span class="line">length, j &#x3D; 0, -1</span><br><span class="line">for i, x in enumerate(s):</span><br><span class="line">    if x in s[j + 1:i]:</span><br><span class="line">        length &#x3D; max(length, i - j - 1)</span><br><span class="line">        j &#x3D; s[j + 1:i].index(x) + j + 1</span><br><span class="line">print(max(length, len(s) - 1 - j))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1 零基础学机器学习</title>
    <link href="/2020/03/01/1-0%E5%9F%BA%E7%A1%80%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/03/01/1-0%E5%9F%BA%E7%A1%80%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="机器学习使用场景"><a href="#机器学习使用场景" class="headerlink" title="机器学习使用场景"></a>机器学习使用场景</h2><p>机器学习已经有了十分广泛的应用，例如：数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人运用。</p><h2 id="模式识别-amp-机器学习-amp-深度学习"><a href="#模式识别-amp-机器学习-amp-深度学习" class="headerlink" title="模式识别&amp;机器学习&amp;深度学习"></a>模式识别&amp;机器学习&amp;深度学习</h2><ul><li><p>模式识别，模式识别就是让计算机也具备有识别东西的能力，比如让计算机识别手写数字数8，这叫做手写识别技术，也是模式识别的一个应用场景，其他的还有语音识别，声纹识别(可以知道你是哪个人)，人脸识别，指纹识别等</p><blockquote><p>我们应该先对计算机进行数据的训练，比如搜集很多手写的8（训练），将他们变成矩阵存储到计算机中，这样计算机就认识8了，当计算机遇到一个新的8时，就会对之前的数据进行匹配，当匹配很近似时，计算机就会认为这就是8</p></blockquote></li><li><p>机器学习，首先，你要搜集很多的数据，以及为程序选择一个算法，然后将数据导入到计算机中，等上一段时间，让计算机自己去学习这些数据</p><blockquote><p>模式识别需要我们去给计算机喂饭，而机器学习就是我们把饭煮好了，让他自己吃</p></blockquote></li><li><p>深度学习，深度学习是机器学习的一个子类，是模仿人类大脑思考而创造的一个方法，利用的是神经网络，往往需要大量的数据，来模拟人脑进行数据的解释<br><a href="https://www.zhihu.com/question/57770020" target="_blank" rel="noopener">机器学习还有很多的缺点</a></p><blockquote><p>机器学习包含深度学习，机器学习适合各种数据量的训练，因此训练时间有长有短，而神经网络的训练需要大量的数据，而且花费的时间比较长</p></blockquote></li></ul><h2 id="大数据-amp-人工智能"><a href="#大数据-amp-人工智能" class="headerlink" title="大数据&amp;人工智能"></a>大数据&amp;人工智能</h2><ul><li>大数据，就是对大量的数据进行存储和分析，由分析结果来进行决策，现在大数据经常和机器学习相结合</li><li>人工只能范围很大，如果有人说自己是做人工智能的，你可以问他是做什么方向的，或者他什么都不知道</li></ul><h2 id="机器学习的组成"><a href="#机器学习的组成" class="headerlink" title="机器学习的组成"></a>机器学习的组成</h2><h3 id="分类-amp-回归"><a href="#分类-amp-回归" class="headerlink" title="分类&amp;回归"></a>分类&amp;回归</h3><ul><li>分类：将数据划分到合适的类别中，例如手写一个新的数据8，计算机会识别，将他归类到8中</li><li>回归：用于数据的预测，先对已有的数据进行分析，得到一个函数</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p><strong>监督学习</strong>，就是人们常说的分类，通过已有的训练样本（即已知数据以及其对应的输出）去训练得到一个最优模型（这个模型属于某个函数的集合，最优则表示在某个评价准则下是最佳的），再利用这个模型将所有的输入映射为相应的输出，对输出进行简单的判断从而实现分类的目的，也就具有了对未知数据进行分类的能力。在人对事物的认识中，我们从孩子开始就被大人们教授这是鸟啊、那是猪啊、那是房子啊，等等。我们所见到的景物就是输入数据，而大人们对这些景物的判断结果（是房子还是鸟啊）就是相应的输出。当我们见识多了以后，脑子里就慢慢地得到了一些泛化的模型，这就是训练得到的那个（或者那些）函数，从而不需要大人在旁边指点的时候，我们也能分辨的出来哪些是房子，哪些是鸟。监督学习里典型的例子就是KNN、SVM。</p><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><p><strong>无监督学习</strong>（也有人叫非监督学习，反正都差不多）则是另一种研究的比较多的学习方法，它与监督学习的不同之处，在于我们事先没有任何训练样本，而需要直接对数据进行建模。这听起来似乎有点不可思议，但是在我们自身认识世界的过程中很多处都用到了无监督学习。比如我们去参观一个画展，我们完全对艺术一无所知，但是欣赏完多幅作品之后，我们也能把它们分成不同的派别（比如哪些更朦胧一点，哪些更写实一些，即使我们不知道什么叫做朦胧派，什么叫做写实派，但是至少我们能把他们分为两个类）。无监督学习里典型的例子就是聚类了。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了。</p><h4 id="聚类和分类的区别"><a href="#聚类和分类的区别" class="headerlink" title="聚类和分类的区别"></a>聚类和分类的区别</h4><ul><li><p>聚类就是没有标准，将数据集中具有同一特征的所有数据设置成一个集合</p></li><li><p>而分类是知道数据的特征，将特征一样的设置成一个集合</p></li></ul><h4 id="强化学习（马尔可夫决策）"><a href="#强化学习（马尔可夫决策）" class="headerlink" title="强化学习（马尔可夫决策）"></a>强化学习（马尔可夫决策）</h4><p>这个算法可以训练程序做出某一决定。程序在某一情况下尝试所有的可能行动，记录不同行动的结果并试着找出最好的一次尝试来做决定。 属于这一类算法的有马尔可夫决策过程。</p><p><strong>马尔可夫性质</strong>是强化学习理论的基石，主要意思是，下一步的状态，只和我们当前的状态有关，而和之前的状态无关（具体以后再介绍）</p><h3 id="机器学习的使用流程"><a href="#机器学习的使用流程" class="headerlink" title="机器学习的使用流程"></a>机器学习的使用流程</h3><ol><li><p>收集数据: 收集样本数据</p></li><li><p>准备数据: 注意数据的格式</p></li><li><p>分析数据: 为了确保数据集中没有垃圾数据；</p></li><li><p>如果是算法可以处理的数据格式或可信任的数据源，则可以跳过该步骤；</p></li><li><p>另外该步骤需要人工干预，会降低自动化系统的价值。</p></li><li><p>训练算法: [机器学习算法核心]如果使用无监督学习算法，由于不存在目标变量值，则可以跳过该步骤</p></li><li><p>测试算法: [机器学习算法核心]评估算法效果</p></li><li><p>使用算法: 将机器学习算法转为应用程序</p></li></ol><h2 id="机器学习的相关模块"><a href="#机器学习的相关模块" class="headerlink" title="机器学习的相关模块"></a>机器学习的相关模块</h2><ul><li><p>Python相关的库</p><ul><li>科学函数库：SciPy、NumPy(底层语言：C和Fortran)</li><li>绘图工具库：Matplotlib</li><li>数据分析库 Pandas<h2 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h2>附：机器学习专业术语</li></ul></li><li><p>模型（model）：计算机层面的认知</p></li><li><p>学习算法（learning algorithm），从数据中产生模型的方法</p></li><li><p>数据集（data set）：一组记录的合集</p></li><li><p>示例（instance）：对于某个对象的描述</p></li><li><p>样本（sample）：也叫示例</p></li><li><p>属性（attribute）：对象的某方面表现或特征</p></li><li><p>特征（feature）：同属性</p></li><li><p>属性值（attribute value）：属性上的取值</p></li><li><p>属性空间（attribute space）：属性张成的空间</p></li><li><p>样本空间/输入空间（samplespace）：同属性空间</p></li><li><p>特征向量（feature vector）：在属性空间里每个点对应一个坐标向量，把一个示例称作特征向量</p></li><li><p>维数（dimensionality）：描述样本参数的个数（也就是空间是几维的）</p></li><li><p>学习（learning）/训练（training）：从数据中学得模型</p></li><li><p>训练数据（training data）：训练过程中用到的数据</p></li><li><p>训练样本（training sample）:训练用到的每个样本</p></li><li><p>训练集（training set）：训练样本组成的集合</p></li><li><p>假设（hypothesis）：学习模型对应了关于数据的某种潜在规则</p></li><li><p>真相（ground-truth）:真正存在的潜在规律</p></li><li><p>学习器（learner）：模型的另一种叫法，把学习算法在给定数据和参数空间的实例化</p></li><li><p>预测（prediction）：判断一个东西的属性</p></li><li><p>标记（label）：关于示例的结果信息，比如我是一个“好人”。</p></li><li><p>样例（example）：拥有标记的示例</p></li><li><p>标记空间/输出空间（label space）：所有标记的集合</p></li><li><p>分类（classification）：预测是离散值，比如把人分为好人和坏人之类的学习任务</p></li><li><p>回归（regression）：预测值是连续值，比如你的好人程度达到了0.9，0.6之类的</p></li><li><p>二分类（binary classification）：只涉及两个类别的分类任务</p></li><li><p>正类（positive class）：二分类里的一个</p></li><li><p>反类（negative class）：二分类里的另外一个</p></li><li><p>多分类（multi-class classification）：涉及多个类别的分类</p></li><li><p>测试（testing）：学习到模型之后对样本进行预测的过程</p></li><li><p>测试样本（testing sample）：被预测的样本</p></li><li><p>聚类（clustering）：把训练集中的对象分为若干组</p></li><li><p>簇（cluster）：每一个组叫簇</p></li><li><p>监督学习（supervised learning）：典范–分类和回归</p></li><li><p>无监督学习（unsupervised learning）：典范–聚类</p></li><li><p>未见示例（unseen instance）：“新样本“，没训练过的样本</p></li><li><p>泛化（generalization）能力：学得的模型适用于新样本的能力</p></li><li><p>分布（distribution）：样本空间的全体样本服从的一种规律</p></li><li><p>独立同分布（independent and identically distributed，简称i,i,d.）:获得的每个样本都是独立地从这个分布上采样获得的。</p></li></ul><h3 id="数据集的划分"><a href="#数据集的划分" class="headerlink" title="数据集的划分"></a>数据集的划分</h3><ul><li>训练集（Training set） —— 学习样本数据集，通过匹配一些参数来建立一个模型，主要用来训练模型。类比考研前做的解题大全。</li><li>验证集（validation set） —— 对学习出来的模型，调整模型的参数，如在神经网络中选择隐藏单元数。验证集还用来确定网络结构或者控制模型复杂程度的参数。类比 考研之前做的模拟考试。</li><li>测试集（Test set） —— 测试训练好的模型的分辨能力。类比 考研。这次真的是一考定终身。</li></ul><h3 id="模型拟合程度"><a href="#模型拟合程度" class="headerlink" title="模型拟合程度"></a>模型拟合程度</h3><ul><li><p>欠拟合（Underfitting）：模型没有很好地捕捉到数据特征，不能够很好地拟合数据，对训练样本的一般性质尚未学好。类比，光看书不做题觉得自己什么都会了，上了考场才知道自己啥都不会。</p></li><li><p>过拟合（Overfitting）：模型把训练样本学习“太好了”，可能把一些训练样本自身的特性当做了所有潜在样本都有的一般性质，导致泛化能力下降。类比，做课后题全都做对了，超纲题也都认为是考试必考题目，上了考场还是啥都不会。</p><p>通俗来说，欠拟合和过拟合都可以用一句话来说，欠拟合就是：“你太天真了！”，过拟合就是：“你想太多了！”。</p></li></ul><h3 id="常见的模型指标"><a href="#常见的模型指标" class="headerlink" title="常见的模型指标"></a>常见的模型指标</h3><ul><li><p>正确率 —— 提取出的正确信息条数 / 提取出的信息条数</p></li><li><p>召回率 —— 提取出的正确信息条数 / 样本中的信息条数</p></li><li><p>F 值 —— 正确率 * 召回率 * 2 / （正确率 + 召回率）（F值即为正确率和召回率的调和平均值）</p><p>举个例子如下：</p><p>举个例子如下： 某池塘有 1400 条鲤鱼，300 只虾，300 只乌龟。现在以捕鲤鱼为目的。撒了一张网，逮住了 700 条鲤鱼，200 只 虾， 100 只乌龟。那么这些指标分别如下： 正确率 = 700 / (700 + 200 + 100) = 70% 召回率 = 700 / 1400 = 50% F 值 = 70% * 50% * 2 / (70% + 50%) = 58.3%</p><h2 id="参考网站推荐"><a href="#参考网站推荐" class="headerlink" title="参考网站推荐"></a>参考网站推荐</h2></li></ul><p>本博客知识来自<code>GitHub</code>上的<a href="https://ailearning.apachecn.org/#/docs/ml/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">ailearning</a></p><p>机器学习有关的数学知识请看<a href="https://zhuanlan.zhihu.com/p/25197792" target="_blank" rel="noopener">知乎</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研初试经验</title>
    <link href="/2020/02/20/%E8%80%83%E7%A0%94%E5%88%9D%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <url>/2020/02/20/%E8%80%83%E7%A0%94%E5%88%9D%E8%AF%95%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>本人是来自江西师范大学的一名学生，考研初试科目包括英语二，数学二，政治，专业课，一共四门科目。考的方向是深圳大学电子通信专业，属于跨专业考试。接下来，我将分享下这一年来的考研心得，最后我会和大家说一些小技巧和需要注意的地方。也推荐大家多去知乎，等其他地方多学学别人的经验，适合自己的才是最有效的。在这我很感谢身边和自习室的同学，是他们给了我巨大的动力，让我坚持下来！</p><p>在这我有几句话想先对大家说下：</p><ol><li>能花钱解决的事，一定不要浪费时间。</li><li>早上去自习室不要太早或者太晚，根据自己的实际情况，效率才最重要</li></ol><h2 id="2-数学考试经验"><a href="#2-数学考试经验" class="headerlink" title="2.数学考试经验"></a>2.数学考试经验</h2><p>本人数学二今年126分，接下来我将分享下我个人的数学学习方法。</p><h3 id="数学复习资料如何选择"><a href="#数学复习资料如何选择" class="headerlink" title="数学复习资料如何选择"></a>数学复习资料如何选择</h3><hr><p>我个人是非常推荐汤家凤老师，看视频和用资料选汤老师比较好。</p><p><strong>当时我的数学资料购买的有：</strong></p><ol><li>汤家凤复习全书</li><li>汤家凤高等数学辅导讲义</li><li>汤家凤线性代数辅导讲义</li><li>李永乐线性代数辅导讲义</li><li>汤家凤1800题</li><li>历年真题(可以买李正元或者李永乐的历年真题解析)</li><li>后期购买李林的6+4模拟卷(11月份左右才出)</li></ol><hr><p><strong>学习的视频有：</strong></p><ol><li>汤家凤高等数学基础阶段视频</li><li>汤家凤线性代数基础阶段视频</li><li>李永乐线性代数提高阶段视频</li></ol><hr><h3 id="学习时间的规划"><a href="#学习时间的规划" class="headerlink" title="学习时间的规划"></a>学习时间的规划</h3><p>本人其实是大二下学期就开始准备考研的，这里着重说下数学的学习时间规划。(本人是有一定的数学基础，但是刚开始复习的时候大部分都忘记了)</p><ul><li>3月份之前，也就是寒假阶段，带了数学书回家但是看的时间不超过6个小时。所以数学可以说是2月25号才正式开始学习的。</li><li>3月份到7月份，差不多到暑假的时候，数学复习完了一遍线性代数和高等数学，并且做了两遍左右的1800<strong>基础部分</strong>，以及一遍辅导讲义<strong>(高数和现代两本辅导讲义)</strong>，主要是用来巩固知识点，期间每天百分之80的时间都是在学习数学的。（期间用的书只有汤老师的，听一节视频写一章节的课程，线性代数这时候没有看李永乐的）<blockquote><p>此时每天花在数学上的时间是8-9小时</p></blockquote></li><li>在进入暑假之前，由于学了后面差不多就把前面忘了，所以在暑假前，利用了一个星期的时间把高数和现代的基础部分又快速过了一遍<blockquote><p>此时每天花在数学上的时间是8-9小时</p></blockquote></li><li>正式进入暑假，意味着数学要全面进入提高阶段了，在进入提高之前，复习了一边高数基础，但是还是会有些题听不懂，但是没有关系，不懂的可以先放一放或者问问其他同学，开始写汤家凤复习全书，边看视频边写全书，期间保持做题手感，现代高数每天都写。全书题目写了三遍，李永乐线性代数看了7遍左右。（之前用的汤家凤辅导讲义没看了，暑假期间只写汤家凤全书的题目，加上李永乐现代辅导讲义的复习）<blockquote><p>此时每天花在数学上的时间是8-9小时</p></blockquote></li><li>全书过了两遍后，差不多就到10月份了，我是10月1号开始写历年真题的，写到11月份，留了最后两年的真题没写。做真题的时候总结错题，反复看错题，和1800的提高部分题目。<blockquote><p>此时每天花在数学上的时间是5-6小时，就是上午一到自习室，看到下午三点</p></blockquote></li><li>11月中旬，李林的六套卷和四套卷出来了后，开始每天一套模拟题，考前两个星期，模拟题差不多做完的话，一定要再看一遍全书，现代辅导讲义，过一遍基础，再过一遍错题。（一定要去做李林的卷子，其他的我不推荐买，后期一定要回归基础）</li></ul><blockquote><p>每天只花一个上午的时间看数学，吃完饭就不看了</p></blockquote><hr><h3 id="数学学习小建议"><a href="#数学学习小建议" class="headerlink" title="数学学习小建议"></a>数学学习小建议</h3><ol><li>一定会遇到不会的题目，你可以加一些数学交流群，比较活跃的那种，自己qq搜索一下就可以了，会要点钱但是不多</li><li>可以找一个网友，数学比较厉害的，一直问他题目(比如自己学校的数学竞赛群，去那里面看，加他好友，最好别人也考研)</li><li>数学错题本，我不推荐手写，这里我介绍一个ipad软件，Marginnote，去商店搜一下，当时我是购买的正版88块钱，因为觉得真的好用，他可以让你拜托抄错题的烦恼，不过缺点就是很多资料都是需要电子版的</li><li>去淘宝和咸鱼上搜一搜资料，很便宜的，不要在乎这点小钱</li><li>平时注意计算，数学计算很重要，就是多写题目，多计算</li><li><strong>反复反复再反复</strong>不要今天用这本，明天用那本，一定要反复看，现代提高我当时写了7遍！！</li><li>关于数学笔记，我自己记了好多笔记，但是最后都没什么时间看，这里推荐marginnote这款软件，让笔记电子化，手指圈一圈就可以了，省了大量时间，而且方便复习</li><li>多看几位老师的资料，可以看张宇的高数18讲，李正元的复习全书，当时我都是用的电子版，再用marginnote记录下来，方便复习，当时只做了这些资料的少部分习题<blockquote><p>这里说下我数学走的弯路吧，3月到9月，每天我都花大量的时间在数学上，在基础阶段时，我边看汤家凤的视频，同时几乎把他的每个字都写下来了，现在感觉当时好傻，浪费了这么多时间。所以这里建议大家能够专门用一本本子，记录一些解题技巧，一定要写上自己的思考过程，这本本子将跟随你到考研前。大概十一月份的时候，数学花的时间越来越少了，考试前我甚至觉得数学上不了一百，这里说句不好听的话，数学灵感真的很重要，就算你平时模拟考试分数再高，考数学那一刻你看到题目没思路，你一样会败北，所以我建议大家一定要反复看基础，注重平时的数学解题思路分析，后期把每一张卷子都当成模拟考研对待。</p></blockquote></li></ol><hr><h2 id="3-英语考试经验"><a href="#3-英语考试经验" class="headerlink" title="3.英语考试经验"></a>3.英语考试经验</h2><p>本人考的英语二，成绩是67分，所以没什么话语权，但是我可以说下，让大家少走点弯路<br><strong>视频选择：</strong></p><ol><li>陈仲恺阅读视频</li><li>微信公众号屠屠老师(每日长难句分析)</li></ol><p><strong>资料选择：</strong></p><ol><li>英语一和英语二的历年真题(考研真相)（张剑黄皮书）</li><li>英语单词新东方绿皮书</li><li>英语练字帖</li><li>王道长的考研英语作文</li></ol><h3 id="英语学习时间规划"><a href="#英语学习时间规划" class="headerlink" title="英语学习时间规划"></a>英语学习时间规划</h3><ol><li>寒假开始就可以背单词了，背单词是要从寒假就坚持到考研当天，当时我是把绿皮书背了六七遍吧，每天一小时左右就行</li><li>3月到5月，我并没有写英语阅读，就是单纯背单词，多背几个意思，<strong>记得每天练字！！</strong></li><li>5月初可以开始先把英语一的九几年的阅读开始慢慢写了，每天保持一定的阅读量，前期一天只写两篇左右，写完了看视频讲解，总结答题技巧</li><li>到了11月份，开始加大阅读题量，一次性写4篇，期间只写阅读，期间新题型和作文等都没开始（英语一的要早点，英语二的可以晚一些准备其他板块，多花点时间在数学上）</li><li>11月初要开始背小作文模板了，当时我是背的王道长的小作文，背了10篇，近几年英语二作文都是综合型的，所以10篇小作文必须全背。期间将除了阅读的其他模块逐一击破。大作文我是到处找模板，自己凑了两个框架来背，为什么我感觉今年深圳那边英语压分啊<blockquote><p>当时我每天的英语时间不超过两个半小时，除了模拟英语考试<br>英语一的一定要早一点，建议学一下基础语法，考英语一的一定要学语法，长难句</p></blockquote></li></ol><h3 id="英语学习小建议"><a href="#英语学习小建议" class="headerlink" title="英语学习小建议"></a>英语学习小建议</h3><ol><li>前期推荐用单词书背诵，不需要默写，认识就行</li><li>后期推荐一款手机软件，anki，控制好自己，上厕所可以背单词，睡觉前瞒着室友偷偷躺在床上背单词，非常方便</li><li>英语字很重要！！！</li><li>把阅读中不会的单词记录到anki卡片中，方便复习！！！</li></ol><blockquote><p>这里说下我走的弯路，希望大家可以避免。前期我每天都背单词，到了十一月，我几乎就没背单词了，英语也是隔三岔五看看，单词一定要坚持背，阅读一定要保持手感，临近考研，你会被四门科目轮流散打，每科有重多的知识点，当时我是上午看数学，下午背政治，晚上还有专业课，英语几乎没什么时间看。考前晚上还失眠，考英语的时候看着阅读差点睡着了。所以这里我建议大家专业课一定要早一点准备（7月份左右），我是八月份才开始慢慢看的，所以感觉时间不够，前期你专业课花的时间多，后期可以挤出时间给英语。</p></blockquote><hr><h2 id="4-政治考试复习"><a href="#4-政治考试复习" class="headerlink" title="4.政治考试复习"></a>4.政治考试复习</h2><p>本人政治72分，花的时间并不多，可以给大家分享下政治学习方法</p><p><strong>视频推荐：</strong></p><ol><li>徐涛或者王吉</li></ol><p><strong>资料选择：</strong></p><ol><li>肖秀荣1000题，anki版题目，不推荐纸制的</li><li>肖秀荣知识点摘要</li><li>王吉三套卷选择题，田维彬预测题，进两年政治真题，肖四肖八选择题(这些都是试卷，只写选择题)</li><li>田维彬时政（不用全看，了解即可，他有时政题目，写下有印象即可）</li></ol><h3 id="政治时间规划"><a href="#政治时间规划" class="headerlink" title="政治时间规划"></a>政治时间规划</h3><ol><li>我是九月份开始政治复习的，一天看两个小时视频，由于感觉后期有点点紧，所以你可以早一点看，但也不推荐太早，看一章视频用anki刷一章题目</li><li>10月底，之前要看完政治视频，自己把握时间，这时候肖8也差不多出来了，肖8出来就不要再看1000题了</li><li>11月中旬到考试前，大量刷王吉三套卷选择题，田维斌预测题，进两年政治真题，肖四肖八选择题(这些都是试卷，只写选择题)</li><li>当你写完肖4选择后，就要开始背分析题了，当时我是考前十天左右，每天花一个下午的时间，找一个安静的地方背肖四分析题，挑关键词背，但是还是好多，背的都想哭来了<blockquote><p>时间不一定，随着临近考试，政治复习时间慢慢增加</p></blockquote></li></ol><h3 id="政治学习小技巧（重要！！）"><a href="#政治学习小技巧（重要！！）" class="headerlink" title="政治学习小技巧（重要！！）"></a>政治学习小技巧（重要！！）</h3><ol><li>一定要记得用anki刷题哦！还是别人推荐给我的，非常好用，上厕所也可以刷政治，不会的一定要百度，因为很多概念</li><li>后期一定要刷那些老师的选择题预测卷，我先说下为什么1000题只刷一两遍，但马原要多写几遍<ul><li>马原部分靠理解，并且很比较灵活，多选错选都没分，所以一定要把握好概念</li><li>其他题型都比较固定，容易和时事政治结合起来，1000题意义不大</li><li>你没这么多时间，政治拉分不多，没必要太多时间</li><li>那些老师的选择题预测卷非常有价值，做完我说的那些就够了，因为他们都会将当年发生的时事政治和相关知识点结合起来，比较贴近考研命题风格，强烈推荐<strong>田维彬</strong>考研政治，他的选择可以压中原题</li></ul></li><li>分析题当时我背的是肖老师的，虽然今年不太准，由于我没太多时间，只背了肖4前两套的（主要）4套卷的马原和毛概，全背了，其他的看重不重要再背。以及部分天维彬预测卷</li><li><strong>考试技巧！</strong>当时我怀疑肖的压得可能会不准，就又找了田维彬的政治押题，他们两押题都很准，不推荐其他考研机构押题。我就对比了下两位老师的分析题押题，发现大部分是一样的，但是田老师压的一些题目感觉没见过，于是我考试前，就特意看了看，记了关键词，然后进考场马上写到草稿纸上，没想到真的考到了一个小题（要知道今年肖4就没压到好像）</li><li>政治字一定要写好，总的来说就是字写好，答案全写满，我这有田维彬的学习群，也就50块钱，包括答疑和学习计划以及学习资料（上面资料里面都有），帮我节省了大量时间，想进可以联系我（QQ747876457）<strong>注意加我的时候备注</strong></li></ol><blockquote><p>本人大学就没怎么学过政治，还只是一个团员，当时9月开始政治，真的感觉时间不够，不过政治学的是最开心的，因为动脑地方不多。后期真的是背的想哭，背着背着我就打电话给自己老妈了…毕竟从小到大没背过这么多东西。我个人是很怕喧闹的环境的，当时换了很多地方背书，最后找了一个比较偏僻的地方，每天都是一个人，真的快背自闭了。考政治当天虽然失眠，但是没办法呀，拿到卷子，本来以为肖老师可以压中原题的，结果全傻眼了，分析题全程在分析题干，背的那些用的不多，光是分析题干，最后没想到也考了个70分，所以要不要背很多，你自己决定把。</p></blockquote><h2 id="5-专业课"><a href="#5-专业课" class="headerlink" title="5.专业课"></a>5.专业课</h2><p>深大专业课是出了名的难，和我同专业的几乎全是90分左右，100以上的非常少，而且每个人专业课不一样，我在这就不多说了，但是建议大家暑假开始的时候就可以着手专业课了，专业课视频哪里看？<strong>去B站和MOOC上搜一下就可以了</strong></p><blockquote><p>这里说下深圳大学电子通信专业课，考试书目有数字电路和数字信号处理，数字电路还好，上手不是那么难，数字信号处理就不一样了，本科没学过，还巨难，傅里叶变换，拉普拉斯变换等，变到你找不到东南西北 。最难的还不是这个，深大专业课指定了两本书，意味着你只要看两本就行了，但是他不考这上面的，只能说题目太超纲了，很多题目都很新颖，改卷非常严格，只要答案错，步骤分就是没有的，所以大家专业课分普遍都不高，这里建议专业课尽量早一些开始把，历年真题可以说是有又没有帮助，是因为你看了题目以后就知道第二年不考什么了，深大就喜欢挑没考过的知识点考，但是会参入少量的重复知识点，所以你必须每个点都掌握。实在不会写的题目，可以找相关的老师帮忙，当时我是实在不会，就花了一个下午的时间找老师帮忙。虽然最后考试还是不会…</p></blockquote><h2 id="6-宾馆选择"><a href="#6-宾馆选择" class="headerlink" title="6.宾馆选择"></a>6.宾馆选择</h2><p>自己订宾馆就行，一定要看好位置，宾馆不要在马路旁，附近一定不要有ktv！！！</p><h2 id="7-小技巧补充"><a href="#7-小技巧补充" class="headerlink" title="7.小技巧补充"></a>7.小技巧补充</h2><ol><li>善用B站和MOOC</li><li>善用咸鱼和淘宝，不要不舍得花钱，这些以后都会赚回来的</li><li>不推荐经常休息</li></ol><h2 id="8-后记"><a href="#8-后记" class="headerlink" title="8.后记"></a>8.后记</h2><p>这里记录我的整个考研心理变化，感兴趣的可以看看，不知道是不是有人和我一样…</p><blockquote><p>三月份，我开始了数学的学习，前期参加了中公的数学培训，多亏了我室友，50块钱上了一星期的数学培训课，酒店是免费的，比较好，前期每天早上背单词，其余时间全在看数学，期间还有些课，大三下学期很多课我都是在看数学的，完全不听老师讲课，水课能不去尽量不去。就这样到了暑假，并且一直给自己打气，不就是考研吗，才几个月，自己肯定坚持的下来。在这期间，中午晚上都和同学一起吃饭，吃完晚饭还会去学校的湖边溜达半小时，每天晚上学到10点，回到寝室就开始玩手机。正式进入暑假了，这时候我还在每天看数学，别人都开始政治了，当时我感觉完全不慌，暑假完成了数学提高，进入八月，越来越多人开始政治学习了，我也在纠结要不要开始，8月20号开始，打算先看看徐涛的视频，不过这期间只看视频没做题目，看了几天就没看了，又继续把政治时间给了数学和专业课。九月开始正式刷政治，当时感觉有点慌了，因为政治好多没看，于是上厕所在看政治，睡前还在看政治，当时很多概念不会，我就一题一题百度，但是确实蛮有效果的，进入十月份，我开始失眠了，因为这时候数学英语政治专业课，每门都要看，还不知道如何分配时间，就到处问别人，看他们是如何准备的。十一月份了，失眠没有了，可能是太累了吧，躺床上就能睡着。每天都是一个人独来独往，吃饭十五分钟就解决了，开始有点没把握了，刚开始想360不是数数手指就能考到吗？写了专业课的题目后，发现我太天真了，而且数学，英语，专业课都没正式测试过，心里也没底，这时压力越来越大了。当时坐在自习室，书看着看着就发起呆来了，想着考上研究生以后或者没考上研究生该怎么办，状态感觉没之前好了。就这样，不知不觉来到考研前一个星期了，当时觉得无所谓了，爱咋地就咋地把，只想快点结束。但是又心想还有好多错题没看，太多的知识点没掌握好，而且最后几天真的是过的超级快呀，一下就到考研前一天了。提前半天去了酒店，当时上午还在自习室，第一次看到自习室少了好多人，想着马上要和这些熟面孔分离一段时间了，就有点想哭，中午吃饭还去看了看二食堂二楼的水果店老板，考研前一个晚上，真的很感谢大家祝我好运呀。第二天是考政治，英语，于是我大量时间就在背政治了，英语就把前两天模拟的19年卷子拿出来看，把握错题的感觉。十一点就准备睡觉了，但是一直没睡着，酒店就在马路旁，货车一直运货到半夜三点。第二天感觉巨困，但是考政治问题不大，mmp，下午考英语，中午就过了一遍作文，写阅读的时候感觉巨困，好想睡觉。考完英语政治后的当天晚上，几乎全在看专业课了，剩下一个小时看数学，看了半小时就感觉巨困，就睡觉了，由于之前那个房间太吵，我就换了个房间。第二天起来，我就看昨晚没看完的数学，看的李林6+4套卷，没想到真的考到了。中午就找到一个安静的吃饭地方，到考试前一直看专业书，并没睡午觉。考完真的感觉时间过得很快呀，你要相信自己一定可以的！加油哦！你一定可以的哟！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>考研经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows系统下用hexo搭建个人博客</title>
    <link href="/2020/02/20/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/20/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="windows利用hexo搭建自己的博客"><a href="#windows利用hexo搭建自己的博客" class="headerlink" title="windows利用hexo搭建自己的博客"></a>windows利用hexo搭建自己的博客</h1><h2 id="采用hexo搭建个人博客"><a href="#采用hexo搭建个人博客" class="headerlink" title="采用hexo搭建个人博客"></a>采用hexo搭建个人博客</h2><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li>百度搜索nodejs网站，下载nodejs软件到电脑上</li></ol><hr><ol start="2"><li>打开cmd，输入<code>npm install -g cnpm --registry-https://registry.npm.taobao.org</code></li><li>接着输入<code>cnpm</code>命令，系统会自动补全命令，输入<code>cnpm -v</code>可以查看安装的版本号。如果有输入，则安装成功</li><li>输入<code>cnpm install -g hexo-cli</code>命令，安装hexo</li><li>输入<code>mkdir blog</code>接下来会在当前目录下创建一个blog文件夹，自己可以去该目录下查看是否生成，输入<code>chdir</code>可以查看目录，会自己显示出来</li><li>此时我们继续在cmd下输入<code>hexo init</code>，会提示报错，所以我们这时候应该打开浏览器，百度搜索git，找到git的官网，下载软件到电脑上，<font color='red'>注意记得安装路径，不要随便添加</font></li></ol><hr><ol start="7"><li><p>下载好git后，我们可以在git的安装路径下发现几个文件 <img src="http://i2.tiimg.com/710246/7b6b9af5b5aa3ce0.png" srcset="/img/loading.gif" alt="Markdown"></p><hr></li><li><p>接下来要添加git到环境变量，首先复制该路径，找到我的电脑，标右键点属性，再点击高级系统设置，可以看到环境变量，找到path点击编辑，将文件路径复制进去即可</p></li></ol><p><img src="http://i2.tiimg.com/710246/bac6d69fed6aa81f.png" srcset="/img/loading.gif" alt="Markdown"><br><img src="http://i2.tiimg.com/710246/c948c3ef2ce69d10.png" srcset="/img/loading.gif" alt="Markdown"><br><img src="http://i2.tiimg.com/710246/0e14c66f125c744b.png" srcset="/img/loading.gif" alt="Markdown"><br><img src="http://i2.tiimg.com/710246/ffd5097a0096077a.png" srcset="/img/loading.gif" alt="Markdown"></p><ol start="9"><li><p>返回git软件安装目录下，打开git-bash软件，打开后可以看到一个类似于cmd窗口的交互界面，<font color='red'>剩下的步骤我们将会在git-bash运行</font></p></li><li><p>按步骤在git-bash里面输入下列代码,最开始我新建的blog文件目录是C:\Users\asus\blog，具体情况看个人安装目录</p><ol><li><code>cd C:</code></li><li><code>cd Users</code></li><li><code>cd asus</code></li><li><code>cd blog</code></li></ol></li><li><p>进到该目录下后，输入<code>hexo init</code>然后就会自动初始化hexo，这里需要等待一段时间，等待完后，我们找到blog目录并打开，会发现里面出现了许多文件，后面制作博客会用到, <font color='red'>不要关闭你的git-bash等下还要用到</font></p></li></ol><hr><h2 id="启动你的blog"><a href="#启动你的blog" class="headerlink" title="启动你的blog"></a>启动你的blog</h2><ol><li>在git-bash中输入<code>hexo s</code>，然后可以发现你的博客端口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><ol start="2"><li>打开浏览器，输入<code>localhost:4000</code>就可以看到你的博客啦<font color='red'>注意不要关闭git-bash</font></li><li>按 Ctrl+C 进行下一步操作</li></ol><hr><h2 id="写你的第一篇博客"><a href="#写你的第一篇博客" class="headerlink" title="写你的第一篇博客"></a>写你的第一篇博客</h2><ol><li>在git-bash里面接着输入<code>hexo n &quot;我的第一篇博客&quot;</code>,然后他会自己创建一个markdown文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n &quot;我的第一篇博客&quot;</span><br><span class="line">INFO  Created: ~\blog\source\_posts\我的第一篇博客.md</span><br></pre></td></tr></table></figure><p>创建的位置是blog下的source文件夹里的_posts</p><ol start="2"><li><p>输入<code>cd source/_posts/</code>进入到该文件夹内，输入<code>dir</code>查看该文件夹里面有什么，结果发现确实生成了一个md文件，建议用Typora软件来编辑markdown文件</p></li><li><p>输入命令<code>cd ../..</code>退回到blog目录下</p></li><li><p>输入<code>hexo clearn</code>清除下数据库 和 <code>hexo g</code>就会为你生成博客，接着我们输入<code>hexo s</code>就可以打开博客了，可以看到里面有你的第一篇博客，博客我们直接在刚才的source里面编辑就可以了，刷新页面，网页里面的博客内容也会刷新</p><p><font color='red'>虽然你的博客生成了，但此时别人还是访问不了</font></p><hr><h2 id="让别人也能访问你的博客"><a href="#让别人也能访问你的博客" class="headerlink" title="让别人也能访问你的博客"></a>让别人也能访问你的博客</h2><p>由于刚才这样写的博客我们只能给自己看，所以我们要把自己的博客部署到网站上去，这里使用的免费方法是github，百度搜索github，登录后新建一个仓库，名字默认是下面的格式<br><img src="http://i2.tiimg.com/710246/bc0b422db61b7e4b.png" srcset="/img/loading.gif" alt="Markdown"><br><img src="http://i2.tiimg.com/710246/eff483274ea75be0.png" srcset="/img/loading.gif" alt="Markdown"><br>创建好了后，返回git-bash中，切换到blog目录下，这时我们要在blog目录下安装一个hexo插件，直接输入命令<code>cnpm install --save hexo-deployer-git</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_config.yml  node_modules  package-lock.json  scaffolds  themes</span><br><span class="line">db.json      package.json  public             source</span><br></pre></td></tr></table></figure><p>我们可以发现生成了一个_config.yml 文件，接着输入<code>notepad _config.yml</code>,电脑会用记事本打开这个文件，在文件最下面，我们可以看到一个#Deployment<br><img src="http://i2.tiimg.com/710246/3be705fa79e51eb9.png" srcset="/img/loading.gif" alt="Markdown"></p></li></ol><p>将下面地址复制进记事本中，修改记事本中的一部分内容，按图片来操作</p><p><font color='red'><strong>注意每个冒号后要加一个空格</strong></font></p><p><img src="http://i2.tiimg.com/710246/90540aa9326a4891.png" srcset="/img/loading.gif" alt="Markdown"><br>修改好后保存退出</p><ol start="5"><li>设置git-bash的身份<br><code>git config --global user.name &quot;xxx&quot;</code><br><code>git config --global user.email &quot;xxx&quot;</code><br>注意空格，或者你直接复制把xxx改成你自己的信息，名字随便取，邮箱可以是qq邮箱<br>然后输入<code>git config user.name</code>and<code>git config user.email</code>查看是否真的生成了信息</li><li>设置好gitbash的身份之后，接着输入<code>hexo d</code>，然后就会要你登录 github<br>例如我自己gitgub账号邮箱是<a href="mailto:747876457@qq.com">747876457@qq.com</a>, gitbash设置的是<a href="mailto:mcspero123@gmail.com">mcspero123@gmail.com</a><br>然后再用密码登录即可</li><li>登录成功后gitbash窗口就在下载东西，等待即可，下载成功后，刷新你的github仓库，会发现生成了很多新的文件<blockquote><p>期间我输入<code>hexo d</code>然后报错了很多次，但是没关系，我们一直输入hexo d命令直到成功即可</p></blockquote></li><li>然后拿仓库名后面的部分，直接复制到浏览器中即可访问你的博客了<br><img src="http://i2.tiimg.com/710246/ca58a5c317e1f955.png" srcset="/img/loading.gif" alt="Markdown"><blockquote><p>例如我的博客地址就是<a href="https://miki123-gif.github.io/" target="_blank" rel="noopener">https://miki123-gif.github.io/</a></p></blockquote></li></ol><hr><h2 id="如何自定义主题"><a href="#如何自定义主题" class="headerlink" title="如何自定义主题"></a>如何自定义主题</h2><ol><li>下载别人的主题<br>这里下载会出现一些问题，是因为主题太大了，gitbash做了下载设置<a href="https://blog.csdn.net/dzhongjie/article/details/81152983" target="_blank" rel="noopener">可以看看这篇文章</a><br>直接先输入<code>git config --global http.postBuffer 524288000</code>就行啦<br>在git-bash窗口中，注意切换到你之前创建的blog文件夹下，输入<br> <code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code><br> <a href="https://github.com/litten/hexo-theme-yilia.git其实是一个别人的仓库名称，我们这里用的是别人写的博客主题,把它复制到themes目录下的yilia文件夹内，要等待一段时间" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git其实是一个别人的仓库名称，我们这里用的是别人写的博客主题,把它复制到themes目录下的yilia文件夹内，要等待一段时间</a></li></ol><p>下载完后，退回到blog目录下，再次找到_config.yml文件，修改里面的theme成yilia<br><img src="http://i2.tiimg.com/710246/be42d7bcf66ebd2c.png" srcset="/img/loading.gif" alt="Markdown"></p><p>然后依次输入指令<code>hexo clean</code> <code>hexo g</code> <code>hexo s</code></p><p>就可以在localhost:4000上看到自己的博客变了一个主题</p><ol start="2"><li><p>将主题推到云端，这样别人就可以访问</p><p>退回到blog目录下，输入<code>hexo d</code>deploy一下，别人就可以看到你的主题了</p></li></ol><h2 id="点击访问我的博客"><a href="#点击访问我的博客" class="headerlink" title="点击访问我的博客"></a><a href="https://miki123-gif.github.io/" target="_blank" rel="noopener">点击访问我的博客</a></h2>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
