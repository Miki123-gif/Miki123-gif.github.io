<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" type="image/png" href="/img/avatar.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content=" keywords: author: Miki language: zh-CN timezone: ">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>kaggle项目实战，Titanic analysis ~ Miki&#39;s blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Miki's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  Thursday, March 19th 2020, 10:08 am
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    3.7k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      16 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2>
<blockquote>
<p>In this challenge, we ask you to build a predictive model that answers the question: “what sorts of people were more likely to survive?” using passenger data (ie name, age, gender, socio-economic class, etc).</p>
</blockquote>
<p>泰坦尼克号灾难发生时，死亡了很多人，但也有一部分人活了下来，我们将提供一些有标签的数据集，请你根据这些数据对建立的模型进行训练，然后再测试没标签的数据集，判断一个人是否会存活下来，选择合适的算法，提高分类的准确率</p>
<ul>
<li>典型的二分类问题，根据年龄、性别等特征，判断一个人是死亡（0），还是存活（1）</li>
</ul>
<h2 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理"></a> 数据预处理</h2>
<pre class="highlight"><code class="">train_data = pd.read_csv(r&quot;C:\Users\asus\Desktop\train.csv&quot;)
# print(train_data.head())##打印前几行数据
print(train_data.describe().loc[:,[&quot;Survived&quot;,&quot;Age&quot;]])##对数据进行统计，按列(特征)进行统计
</code></pre>
<ul>
<li>读取文件，用<code>head(3)</code>方法打印前进行数据，观察数据的内容</li>
<li>使用<code>describe()</code>方法，对数据的每一列进行统计，统计的内容有（行数，平均值，方差，最小值，最大值）</li>
<li>使用<code>loc()</code>方法，对数据进行切片，数据量太大会显示不出来</li>
</ul>
<pre class="highlight"><code class="">		Survived         Age
count  891.000000  714.000000
mean     0.383838   29.699118
std      0.486592   14.526497
min      0.000000    0.420000
25%      0.000000   20.125000
50%      0.000000   28.000000
75%      1.000000   38.000000
max      1.000000   80.000000
</code></pre>
<pre class="highlight"><code class="">       PassengerId    Survived      Pclass  ...       SibSp       Parch        Fare
count   891.000000  891.000000  891.000000  ...  891.000000  891.000000  891.000000
mean    446.000000    0.383838    2.308642  ...    0.523008    0.381594   32.204208
std     257.353842    0.486592    0.836071  ...    1.102743    0.806057   49.693429
</code></pre>
<p><font color='red'> 我们可以看到，直接<code>describe()</code>的话，数据是显示不完全的，当我们对数据进行统计时，发现年龄这一栏的数据，有些缺失了</font></p>
<h3 id="对缺失数据的填充"><a class="markdownIt-Anchor" href="#对缺失数据的填充"></a> 对缺失数据的填充</h3>
<pre class="highlight"><code class="">train_data['Age'] = train_data['Age'].fillna(train_data['Age'].median())
print(train_data['Age'].median())
</code></pre>
<ol>
<li>pandas可以按行索引也可以按标签进行索引，这里按标签进行索引</li>
<li>由于<code>Age</code>这一列数据有缺失，我们必须将数据进行填补，选取平均值进行填充，使用<code>fillna()</code>方法和<code>median()</code>方法</li>
<li><code>train_data['Age'] = train_data['Age'].fillna(train_data['Age'].median())</code>,对<code>Age</code>列计算平均值并进行填充，再进行赋值**(等号右边操作不会影响原来的列)**</li>
</ol>
<pre class="highlight"><code class="">print(train_data.describe().loc[:, ['Survived', 'Age']])
</code></pre>
<pre class="highlight"><code class="">         Survived         Age
count  891.000000  891.000000
mean     0.383838   29.361582
std      0.486592   13.019697
</code></pre>
<ul>
<li>填充完以后的效果</li>
</ul>
<hr />
<pre class="highlight"><code class="">from collections import Counter
print(Counter(train.Embarked))
</code></pre>
<pre class="highlight"><code class="">Counter({'S': 644, 'C': 168, 'Q': 77, nan: 2})
</code></pre>
<p><font color='red'>我们还可以看到，登船这一数据，有两个值是缺失的，我们需要用S补上，因为S是最多的，所以这两个空值是S的概率也就越高</font></p>
<pre class="highlight"><code class="">train['Embarked'] = train['Embarked'].fillna(&quot;S&quot;)
train.loc[train.Embarked == 'S',['Embarked']], train.loc[train.Embarked == 'C',['Embarked']], \
train.loc[train.Embarked == 'Q',['Embarked']] = 0, 1, 2
</code></pre>
<ul>
<li>数据处理完毕</li>
</ul>
<hr />
<h3 id="将字符串类型数据转换成整型或浮点型"><a class="markdownIt-Anchor" href="#将字符串类型数据转换成整型或浮点型"></a> 将字符串类型数据转换成整型或浮点型</h3>
<pre class="highlight"><code class="">print(train_data['Sex'].head())
</code></pre>
<pre class="highlight"><code class="">0      male
1    female
2    female
3    female
4      male
</code></pre>
<p><strong>我们可以发现性别这一栏的数据都是字符串类型的，所以我们需要将字符串转换成浮点型或者整型</strong></p>
<blockquote>
<p>将女性标记为0，男性标记为1</p>
</blockquote>
<ul>
<li>思路：用pandas中的布尔索引法，对数据进行修改</li>
</ul>
<pre class="highlight"><code class="">train.loc[train.Sex == &quot;male&quot;, ['Sex']], train.loc[train.Sex == &quot;female&quot;, ['Sex']] = 1,0
</code></pre>
<pre class="highlight"><code class="">0      1
1      0
2      0
3      0
4      1
</code></pre>
<h2 id="交叉验证"><a class="markdownIt-Anchor" href="#交叉验证"></a> 交叉验证</h2>
<ul>
<li>先介绍下什么是交叉验证</li>
</ul>
<p>叉验证的基本思想是重复地使用数据；把给定的数据进行切分，将切分的数据组合为训练集和测试集，在此基础上反复地进行训练、测试以及模型选择。</p>
<p>简单交叉验证是：首先随机地将已给数据分成两部分，一部分作为训练集，另一部分作为测试集（比如，70%的数据为训练集，30%的数据为测试集）；然后用训练集在各种情况下（例如，不同的参数个数）训练模型，从而得到不同的模型；在测试集上评价各个模型的测试误差，选出测试误差最小的模型。</p>
<p><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_cv_indices_0041.png" srcset="/img/loading.gif" alt="../_images/sphx_glr_plot_cv_indices_0041.png" /></p>
<p>我们可以发现，每个数据都会被用到测试，也会被用到进行训练</p>
<pre class="highlight"><code class="">&gt;&gt;&gt; X = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
&gt;&gt;&gt; kf = KFold(n_splits=2)
&gt;&gt;&gt; for train, test in kf.split(X):
...     print(&quot;%s %s&quot; % (train, test))
[2 3] [0 1]
[0 1] [2 3]
</code></pre>
<h2 id="选择算法"><a class="markdownIt-Anchor" href="#选择算法"></a> 选择算法</h2>
<h3 id="多元线性回归模型"><a class="markdownIt-Anchor" href="#多元线性回归模型"></a> 多元线性回归模型</h3>
<p>当特征量比较多时，我们可以建立多元线性回归模型，来对数据进行预测，虽然效果可能不好，但是我们可以先用这个方法进行测试</p>
<pre class="highlight"><code class="">algorithm = LinearRegression()
</code></pre>
<p>使用k折交叉分类方法，将数据进行拆分，分成</p>
<pre class="highlight"><code class="">kf = KFold(n_splits=3, shuffle=True, random_state=1)
predictions = []
for each_train, test in kf.split(train):
</code></pre>
<p>可以看到，拆分只是挑选了数据的序号</p>
<pre class="highlight"><code class="">[  0   3   4   6   7   9  11  13  15  16  19  21  22  23  24  25  26  28
  29  32  33  35  36  38  41  42  43  44  46  47  51  53  56  57  58  59
  61  63  66  67  69  70  72  73  74  78  80  81  82  83  84  86  87  88···]
</code></pre>
<ul>
<li><code>n_splits=3</code>表示数据会分三次，也就是说，先将数据分成两部分，一部分用来训练，一部分用来测试，第二次分又会随机分，再挑一部分作为训练，一部分用来测试，一共分三次</li>
</ul>
<p>打印一下循环中的那些代码：（用来进行测试的）</p>
<p>先选取这些特征标签，定位到他们测试集的数据</p>
<pre class="highlight"><code class="">predictors = ['Pclass', 'Sex', 'Age', 'SibSp','Parch', 'Fare', 'Embarked']
print(train[predictors].iloc[each_train, :].head())
</code></pre>
<pre class="highlight"><code class="">   Pclass  Sex   Age  SibSp  Parch     Fare  Embarked
1       1    1  38.0      1      0  71.2833         1
4       3    0  35.0      0      0   8.0500         0
5       3    0  28.0      0      0   8.4583         2
7       3    0   2.0      3      1  21.0750         0
9       2    1  14.0      1      0  30.0708         1
</code></pre>
<ol>
<li>首先进行训练，挑选出特征和结果(标签)，进行分析，也就是训练好下面的系数</li>
<li>挑选出待预测的，作为新的输入，每输入一个就会得到一个输出，我们发现下面这个输出几乎都是在0-1区间的</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181119004628363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlcGVuZ3M=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img" /></p>
<pre class="highlight"><code class="">train_data = (train[predictors].iloc[each_train, :])
train_target = (train['Survived'].iloc[each_train])
algorithm.fit(train_data, train_target)
test_pre = algorithm.predict(train[predictors].iloc[test, :])
print(test_pre)
</code></pre>
<pre class="highlight"><code class="">[ 0.06437899  0.61788304  0.87297606  0.29033014  0.64169133  0.03664443
  0.69135238  0.12120566  0.26493885  0.64810848  0.4479658   0.43909047
  0.30794885  0.47643842  0.73801641  0.1135054   0.69069692  0.61193961
</code></pre>
<p>由于这里预测的是数组，我们需要用到<code>extend</code>方法，和<code>append</code>方法有什么区别可以自己试试</p>
<pre class="highlight"><code class="">count = 0
for key, values in enumerate(tag):
    if predictions[key] &gt;= 0.5:
        predictions[key] = 1
    else:
        predictions[key] = 0
    if predictions[key] != train.Survived[values]:
        count += 1
print(f'rate={1 - (count/len(train))}')
</code></pre>
<ul>
<li>这里我们让大于0.5的认定为存活下来，小于0.5的则没存活</li>
</ul>
<pre class="highlight"><code class="">rate=0.7901234567901234
</code></pre>
<ul>
<li><strong>结果准确率只有0.79，看来是不算太高的</strong></li>
</ul>
<p><strong>这里先大致讲一下思路：</strong></p>
<pre class="highlight"><code class="">kf = KFold(n_splits=2, shuffle=True, random_state=1)
for each_train, test in kf.split(train):
	print(each_train)
    print(test)
</code></pre>
<pre class="highlight"><code class="">1   7  10  15
 0   2   3   4   
 0   2   3   4   
 1   7  10  15
</code></pre>
<ul>
<li>由此可见分成了两部分，每一个数据都会被测试，也都会被用来当作训练</li>
</ul>
<pre class="highlight"><code class="">for each_train, test in kf.split(train):
    train_data = (train[predictors].iloc[each_train, :])
    train_target = (train['Survived'].iloc[each_train])
    algorithm.fit(train_data, train_target)
    test_pre = algorithm.predict(train[predictors].iloc[test, :])
    predictions.extend(test_pre)
    tag.extend(test)
</code></pre>
<ul>
<li><code>fit(train_data, train_target)</code>这一步是进行数据的训练</li>
<li><code>predict(train[predictors].iloc[test, :])数据的预测</code>，输出是一系列介于0-1之间的小数</li>
<li><code>predictions.extend(test_pre)</code> <code>tag.extend(test)</code>由于数据是打乱的，所以要将标签搜集起来</li>
</ul>
<p><strong>完整代码如下：</strong></p>
<pre class="highlight"><code class="">import pandas as pd
from collections import Counter
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import KFold

train = pd.read_csv(r&quot;C:\Users\asus\Desktop\train.csv&quot;)
# print(train.head())##打印前几行数据
# print(train.describe().loc['Survived', 'Age'])##对数据进行统计，按列(特征)进行统计
train['Age'] = train['Age'].fillna(train['Age'].median())
# print(train.describe().loc[:, ['Survived', 'Age']])
# 这里使用loc方法，Sex列的所有满足条件的
train.loc[train.Sex == &quot;male&quot;, ['Sex']], train.loc[train.Sex == &quot;female&quot;, ['Sex']] = 0, 1
# print(Counter(train.Embarked))
train['Embarked'] = train['Embarked'].fillna(&quot;S&quot;)
train.loc[train.Embarked == 'S',['Embarked']], train.loc[train.Embarked == 'C',['Embarked']], \
train.loc[train.Embarked == 'Q',['Embarked']] = 0, 1, 2
# print(Counter(train.Embarked))
# print(train.Embarked.describe())
predictors = ['Pclass', 'Sex', 'Age', 'SibSp','Parch', 'Fare', 'Embarked']
# print(train.columns) 打印标签
algorithm = LinearRegression()
kf = KFold(n_splits=2, shuffle=True, random_state=1)
predictions = []
tag = []
for each_train, test in kf.split(train):
    train_data = (train[predictors].iloc[each_train, :])
    train_target = (train['Survived'].iloc[each_train])
    algorithm.fit(train_data, train_target)
    test_pre = algorithm.predict(train[predictors].iloc[test, :])
    predictions.extend(test_pre)
    tag.extend(test)
count = 0
for key, values in enumerate(tag):
    if predictions[key] &gt;= 0.5:
        predictions[key] = 1
    else:
        predictions[key] = 0
    if predictions[key] != train.Survived[values]:
        count += 1
print(f'rate={1 - (count/len(train))}')
</code></pre>
<blockquote>
<p><strong>准确率只有0.79</strong></p>
<p>如果我将&gt;0.6视为存活的话，准确率将达到百分之八十</p>
</blockquote>
<h2 id="模型改进1"><a class="markdownIt-Anchor" href="#模型改进1"></a> 模型改进1</h2>
<h3 id="逻辑回归算法"><a class="markdownIt-Anchor" href="#逻辑回归算法"></a> 逻辑回归算法</h3>
<p><code>rate=0.797979797979798</code></p>
<p>代码改进如下：</p>
<p><code>from sklearn.linear_model import LogisticRegression</code></p>
<p><code>algorithm = LogisticRegression(solver='liblinear')</code></p>
<pre class="highlight"><code class="">count = 0
for key, values in enumerate(tag):
    if predictions[key] != train.Survived[values]:
        count += 1
</code></pre>
<ul>
<li>总的来说就是不需要讨论&gt; 0.5就是1了，不需要对数据进行处理了，逻辑回归算法就是对数据进行分类的，而线性回归预测的值是连续的</li>
<li>只要对原先的代码进行上诉三点改进即可</li>
</ul>
<h2 id="模型改进2"><a class="markdownIt-Anchor" href="#模型改进2"></a> 模型改进2</h2>
<h3 id="随机森林算法"><a class="markdownIt-Anchor" href="#随机森林算法"></a> 随机森林算法</h3>
<blockquote>
<p>随机森林是由多颗决策树组合而成的，假如有三颗决策树，分别输出结果是011，那么最后采取投票的方式，认定结果是1</p>
<p>随机森林的随机体现在：</p>
<ul>
<li>抽样随机，样本是有放回地抽取</li>
<li>特征选取随机，比如从特征中选取年龄，性别等特征，判断哪个特征影响比较大</li>
</ul>
</blockquote>
<p>代码改进：</p>
<pre class="highlight"><code class="">from sklearn.ensemble import RandomForestClassifier
algorithm = RandomForestClassifier(random_state=1, n_estimators=80, min_samples_split=2, min_samples_leaf=1)
</code></pre>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>random_state=1</code>表示每次随机都会得到一样的结果，如果不设置这个值，每次程序运行都会得到不一样的值</li>
<li><code>n_estimators=80</code>表示决策树的数量，越多准确率会相对于更高</li>
<li><code>min_samples_split=2, min_samples_leaf=1</code>，停止条件
<ul>
<li><code>min_samples_split=2</code>表示最小分的数量为2，则停止分裂</li>
<li><code>min_samples_leaf=1</code>当叶子结点为1时，停止分裂</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="">algorithm = RandomForestClassifier(random_state=1, n_estimators=80, min_samples_split=4, min_samples_leaf=2)
</code></pre>
<p><strong>如果对参数继续进行修改</strong>，使得决策树的层数更深，则准确率将会进一步提升</p>
<pre class="highlight"><code class="">rate=0.8249158249158249
</code></pre>
<ol>
<li><strong>n_estimators</strong>: 也就是最大的弱学习器的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，计算量会太大，并且n_estimators到一定的数量后，再增大n_estimators获得的模型提升会很小，所以一般选择一个适中的数值。默认是100。</li>
</ol>
<p><a href="https://www.cnblogs.com/pinard/p/6160412.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">随机森林参数详解</a></p>
<h2 id="特征提取与模型的进一步改进重要"><a class="markdownIt-Anchor" href="#特征提取与模型的进一步改进重要"></a> 特征提取与模型的进一步改进(重要)</h2>
<table>
<thead>
<tr>
<th>Pclass</th>
<th>Name</th>
<th>Sex</th>
<th>Age</th>
<th>SibSp</th>
<th>Parch</th>
<th>Ticket</th>
<th>Fare</th>
<th>Cabin</th>
<th>Embarked</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>Braund, Mr. Owen Harris</td>
<td>male</td>
<td>22</td>
<td>1</td>
<td>0</td>
<td>A/5 21171</td>
<td>7.25</td>
<td></td>
<td>S</td>
</tr>
<tr>
<td>1</td>
<td>Cumings, Mrs. John Bradley (Florence Briggs Thayer)</td>
<td>female</td>
<td>38</td>
<td>1</td>
<td>0</td>
<td>PC 17599</td>
<td>71.2833</td>
<td>C85</td>
<td>C</td>
</tr>
</tbody>
</table>
<p><strong>在前面的模型中，我们并没有考虑到姓名，家庭成员数对生存的影响</strong></p>
<p>对模型进行进一步假设：</p>
<ul>
<li>在美国，似乎名字越长，身份也就越重要，因此可以尝试把<strong>姓名长度</strong>，<strong>作为一个新的特征</strong></li>
<li><code>Cumings, Mrs. John Bradley (Florence Briggs Thayer)</code>,随便观察一个名字，我们可以发现其中藏着一个人的身份，因此可以对所有名字进行一个统计<code>Mrs</code>,作为一个新特征</li>
<li>家庭成员数，似乎对能否生存也有一定的影响</li>
</ul>
<pre class="highlight"><code class="">import pandas as pd
import re

train = pd.read_csv(r'C:\Users\asus\Desktop\train.csv')
r = re.compile(r', (.*?). ', re.S)
length_of_name = []
name_tag = {}
for each_name in train.Name:
    length_of_name.append(len(each_name))
    tag = re.search(r, each_name).group(1)
    if tag not in name_tag:
        name_tag[tag] = 0
    name_tag[tag] += 1
</code></pre>
<pre class="highlight"><code class="">{'Mr': 517, 'Mrs': 125, 'Miss': 182
</code></pre>
<ul>
<li>正则表达式中<code>group()</code>会将正则中用<code>()</code>括起来的直接输出</li>
</ul>
<pre class="highlight"><code class="">import pandas as pd
import re

train = pd.read_csv(r'C:\Users\asus\Desktop\train.csv')
#使用正则对姓名进行处理
r = re.compile(r', (.*?). ', re.S)
length_of_name = []
name_tag = {}
name =[]
for each_name in train.Name:
    length_of_name.append(len(each_name))
    tag = re.search(r, each_name).group(1)
    name.append(tag)
    if tag not in name_tag:
        name_tag[tag] = 0
    name_tag[tag] += 1
#zip直接输出是一个迭代器类型，要转换成字典
tag_map = dict(zip(name_tag.keys(), [i for i in range(1, len(name_tag) + 1)]))
name_tag_digit = []
for each in name:
    name_tag_digit.append(tag_map[each])
#加上新特征
train['length of name'] = length_of_name
train['name tag'] = name_tag_digit
print(train.head())
</code></pre>
<ul>
<li>这一段代码计算了名字的长度新标签，设定了身份代码，<code>Mr=1，Mrs=2...</code></li>
</ul>
<pre class="highlight"><code class="">   PassengerId  Survived  Pclass  ... Embarked length of name  name tag
0            1         0       3  ...        S             23         1
1            2         1       1  ...        C             51         2
</code></pre>
<h2 id="判断特征的重要程度特征选择重要"><a class="markdownIt-Anchor" href="#判断特征的重要程度特征选择重要"></a> 判断特征的重要程度(特征选择)(重要！！！)</h2>
<p>判断某个参数对是否生存的影响程度</p>
<p><a href="https://github.com/fuqiuai/sklearn-feature-engineering" target="_blank" rel="noopener">参考Github，特征选择</a>，介绍了数据映射到0-1区间的方法，归一化处理</p>
<blockquote>
<p>特征选择就是先单独拿出某一项特征，对数据进行拟合，得到一个错误率1，当我们向这个特征中添加某些数据时，再进行拟合，会得到错误率2，如果错误率上升的越厉害，则说明这个特征影响能力越大</p>
<pre class="highlight"><code class="">
</code></pre>
</blockquote>
<p><a href="https://blog.csdn.net/baidu_37995814/article/details/98727766" target="_blank" rel="noopener">当matplotlib画图文字遮挡怎么处理</a></p>
<p><img src="http://q6ip4it64.bkt.clouddn.com/%E7%89%B9%E5%BE%81.png?e=1584711672&amp;token=IeqxMYJS9TcEnX8V6lUXD9FF_y3SCdOBApPAMpRy:olQmhX0_b8dbAi2bEz4kgpoANFY=&amp;attname=" srcset="/img/loading.gif" alt="http://q6ip4it64.bkt.clouddn.com/%E7%89%B9%E5%BE%81.png?e=1584711672&amp;token=IeqxMYJS9TcEnX8V6lUXD9FF_y3SCdOBApPAMpRy:olQmhX0_b8dbAi2bEz4kgpoANFY=&amp;attname=" /></p>
<ul>
<li>从图中可以看出这些参数的影响程度</li>
</ul>
<h2 id="pandas数据归一化"><a class="markdownIt-Anchor" href="#pandas数据归一化"></a> pandas数据归一化</h2>
<pre class="highlight"><code class="">#归一化
norm_data =(train[predictors] - train[predictors].min()) / (train[predictors].max() - train[predictors].min())
</code></pre>
<h2 id="完整程序"><a class="markdownIt-Anchor" href="#完整程序"></a> 完整程序</h2>
<pre class="highlight"><code class="">import pandas as pd
import re
import numpy as np
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import f_classif
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import KFold

train = pd.read_csv(r'C:\Users\asus\Desktop\train.csv')
r = re.compile(r', (.*?). ', re.S)
length_of_name = []
name_tag = {}
name = []

train['Age'] = train['Age'].fillna(train['Age'].median())
# print(train.describe().loc[:, ['Survived', 'Age']])
# 这里使用loc方法，Sex列的所有满足条件的
train.loc[train.Sex == &quot;male&quot;, ['Sex']], train.loc[train.Sex == &quot;female&quot;, ['Sex']] = 0, 1
# print(Counter(train.Embarked))
train['Embarked'] = train['Embarked'].fillna(&quot;S&quot;)
train.loc[train.Embarked == 'S', ['Embarked']], train.loc[train.Embarked == 'C', ['Embarked']], \
train.loc[train.Embarked == 'Q', ['Embarked']] = 0, 1, 2
for each_name in train.Name:
    length_of_name.append(len(each_name))
    tag = re.search(r, each_name).group(1)
    name.append(tag)
    if tag not in name_tag:
        name_tag[tag] = 0
    name_tag[tag] += 1
tag_map = dict(zip(name_tag.keys(), [i for i in range(1, len(name_tag) + 1)]))
name_tag_digit = []
for each in name:
    name_tag_digit.append(tag_map[each])
train['length of name'] = length_of_name
train['name tag'] = name_tag_digit
# print(train['length of name'])
# columns可以打印标签
# predictors = list(train.columns[2:])
predictors = ['Pclass', 'Sex', 'Age', 'SibSp', 'Parch', 'Fare', 'length of name', 'name tag', 'Embarked']
#归一化
norm_data =(train[predictors] - train[predictors].min()) / (train[predictors].max() - train[predictors].min())

selector = SelectKBest(f_classif, k=5)
selector.fit(norm_data, train['Survived'])
scores = -np.log10(selector.pvalues_)
plt.figure()
plt.bar(range(len(predictors)), scores)
plt.xticks([i for i in range(9)], predictors, rotation=30)
plt.show()
algorithm = RandomForestClassifier(random_state=1, n_estimators=120, min_samples_split=3, min_samples_leaf=2)
kf = KFold(n_splits=2, shuffle=True, random_state=1)
predictions = []
tag = []
for each_train, test in kf.split(train):
    train_data = (train[predictors].iloc[each_train, :])
    train_target = (train['Survived'].iloc[each_train])
    algorithm.fit(train_data, train_target)
    test_pre = algorithm.predict(train[predictors].iloc[test, :])
    predictions.extend(test_pre)
    tag.extend(test)
count = 0
for key, values in enumerate(tag):
    if predictions[key] != train.Survived[values]:
        count += 1
print(f'rate={1 - (count/len(train))}')
</code></pre>
<pre class="highlight"><code class="">rate=0.8260381593714927
</code></pre>
<ul>
<li>最好的结果还是只有百分之八十多，还需要拜读其他人的作品</li>
</ul>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98">项目实战</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">机器学习</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->

  <div class="col-lg-7 mx-auto nopadding-md">
    <div class="container custom post-content mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  <script src="/js/post.js" ></script>
  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
    <script>
      $(document).ready(function () {
        tocbot.init({
          tocSelector: '#tocbot',
          contentSelector: '.post-content',
          headingSelector: 'h1,h2,h3,h4,h5,h6',
          linkClass: 'tocbot-link',
          activeLinkClass: 'tocbot-active-link',
          listClass: 'tocbot-list',
          isCollapsedClass: 'tocbot-is-collapsed',
          collapsibleClass: 'tocbot-is-collapsible',
          scrollSmooth: true,
        });
      });
    </script>
  



  <script src="/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  ');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "kaggle项目实战，Titanic analysis&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>



  

  
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });

    </script>

    <script src="https://cdn.staticfile.org/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML" ></script>

  



  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
